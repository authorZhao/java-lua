// Generated by jextract

package com.git.lua;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static com.git.lua.LuaLib.SYMBOL_LOOKUP;
import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class luahpp_h {

    luahpp_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }


    public static final OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final OfInt C_INT = ValueLayout.JAVA_INT;
    public static final OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _VCRT_COMPILER_PREPROCESSOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _VCRT_COMPILER_PREPROCESSOR 1
     * }
     */
    public static int _VCRT_COMPILER_PREPROCESSOR() {
        return _VCRT_COMPILER_PREPROCESSOR;
    }
    private static final int _SAL_VERSION = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SAL_VERSION 20
     * }
     */
    public static int _SAL_VERSION() {
        return _SAL_VERSION;
    }
    private static final int __SAL_H_VERSION = (int)180000000L;
    /**
     * {@snippet lang=c :
     * #define __SAL_H_VERSION 180000000
     * }
     */
    public static int __SAL_H_VERSION() {
        return __SAL_H_VERSION;
    }
    private static final int _USE_DECLSPECS_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_DECLSPECS_FOR_SAL 0
     * }
     */
    public static int _USE_DECLSPECS_FOR_SAL() {
        return _USE_DECLSPECS_FOR_SAL;
    }
    private static final int _USE_ATTRIBUTES_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_ATTRIBUTES_FOR_SAL 0
     * }
     */
    public static int _USE_ATTRIBUTES_FOR_SAL() {
        return _USE_ATTRIBUTES_FOR_SAL;
    }
    private static final int _CRT_PACKING = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _CRT_PACKING 8
     * }
     */
    public static int _CRT_PACKING() {
        return _CRT_PACKING;
    }
    private static final int _HAS_EXCEPTIONS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _HAS_EXCEPTIONS 1
     * }
     */
    public static int _HAS_EXCEPTIONS() {
        return _HAS_EXCEPTIONS;
    }
    private static final int _HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX17 0
     * }
     */
    public static int _HAS_CXX17() {
        return _HAS_CXX17;
    }
    private static final int _HAS_CXX20 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX20 0
     * }
     */
    public static int _HAS_CXX20() {
        return _HAS_CXX20;
    }
    private static final int _HAS_NODISCARD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_NODISCARD 0
     * }
     */
    public static int _HAS_NODISCARD() {
        return _HAS_NODISCARD;
    }
    private static final int CHAR_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CHAR_BIT 8
     * }
     */
    public static int CHAR_BIT() {
        return CHAR_BIT;
    }
    private static final int SCHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MAX 127
     * }
     */
    public static int SCHAR_MAX() {
        return SCHAR_MAX;
    }
    private static final int UCHAR_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UCHAR_MAX 255
     * }
     */
    public static int UCHAR_MAX() {
        return UCHAR_MAX;
    }
    private static final int MB_LEN_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define MB_LEN_MAX 5
     * }
     */
    public static int MB_LEN_MAX() {
        return MB_LEN_MAX;
    }
    private static final int SHRT_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MAX 32767
     * }
     */
    public static int SHRT_MAX() {
        return SHRT_MAX;
    }
    private static final int USHRT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define USHRT_MAX 65535
     * }
     */
    public static int USHRT_MAX() {
        return USHRT_MAX;
    }
    private static final int INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_MAX 2147483647
     * }
     */
    public static int INT_MAX() {
        return INT_MAX;
    }
    private static final int LUA_INT_INT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_INT_INT 1
     * }
     */
    public static int LUA_INT_INT() {
        return LUA_INT_INT;
    }
    private static final int LUA_INT_LONG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_INT_LONG 2
     * }
     */
    public static int LUA_INT_LONG() {
        return LUA_INT_LONG;
    }
    private static final int LUA_INT_LONGLONG = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_INT_LONGLONG 3
     * }
     */
    public static int LUA_INT_LONGLONG() {
        return LUA_INT_LONGLONG;
    }
    private static final int LUA_FLOAT_FLOAT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_FLOAT_FLOAT 1
     * }
     */
    public static int LUA_FLOAT_FLOAT() {
        return LUA_FLOAT_FLOAT;
    }
    private static final int LUA_FLOAT_DOUBLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_FLOAT_DOUBLE 2
     * }
     */
    public static int LUA_FLOAT_DOUBLE() {
        return LUA_FLOAT_DOUBLE;
    }
    private static final int LUA_FLOAT_LONGDOUBLE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_FLOAT_LONGDOUBLE 3
     * }
     */
    public static int LUA_FLOAT_LONGDOUBLE() {
        return LUA_FLOAT_LONGDOUBLE;
    }
    private static final int LUA_32BITS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_32BITS 0
     * }
     */
    public static int LUA_32BITS() {
        return LUA_32BITS;
    }
    private static final int LUA_C89_NUMBERS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_C89_NUMBERS 0
     * }
     */
    public static int LUA_C89_NUMBERS() {
        return LUA_C89_NUMBERS;
    }
    private static final int LUAI_MAXSTACK = (int)1000000L;
    /**
     * {@snippet lang=c :
     * #define LUAI_MAXSTACK 1000000
     * }
     */
    public static int LUAI_MAXSTACK() {
        return LUAI_MAXSTACK;
    }
    private static final int LUA_IDSIZE = (int)60L;
    /**
     * {@snippet lang=c :
     * #define LUA_IDSIZE 60
     * }
     */
    public static int LUA_IDSIZE() {
        return LUA_IDSIZE;
    }
    private static final int LUA_VERSION_NUM = (int)504L;
    /**
     * {@snippet lang=c :
     * #define LUA_VERSION_NUM 504
     * }
     */
    public static int LUA_VERSION_NUM() {
        return LUA_VERSION_NUM;
    }
    private static final int LUA_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_OK 0
     * }
     */
    public static int LUA_OK() {
        return LUA_OK;
    }
    private static final int LUA_YIELD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_YIELD 1
     * }
     */
    public static int LUA_YIELD() {
        return LUA_YIELD;
    }
    private static final int LUA_ERRRUN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_ERRRUN 2
     * }
     */
    public static int LUA_ERRRUN() {
        return LUA_ERRRUN;
    }
    private static final int LUA_ERRSYNTAX = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_ERRSYNTAX 3
     * }
     */
    public static int LUA_ERRSYNTAX() {
        return LUA_ERRSYNTAX;
    }
    private static final int LUA_ERRMEM = (int)4L;
    /**
     * {@snippet lang=c :
     * #define LUA_ERRMEM 4
     * }
     */
    public static int LUA_ERRMEM() {
        return LUA_ERRMEM;
    }
    private static final int LUA_ERRERR = (int)5L;
    /**
     * {@snippet lang=c :
     * #define LUA_ERRERR 5
     * }
     */
    public static int LUA_ERRERR() {
        return LUA_ERRERR;
    }
    private static final int LUA_TNIL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_TNIL 0
     * }
     */
    public static int LUA_TNIL() {
        return LUA_TNIL;
    }
    private static final int LUA_TBOOLEAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_TBOOLEAN 1
     * }
     */
    public static int LUA_TBOOLEAN() {
        return LUA_TBOOLEAN;
    }
    private static final int LUA_TLIGHTUSERDATA = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_TLIGHTUSERDATA 2
     * }
     */
    public static int LUA_TLIGHTUSERDATA() {
        return LUA_TLIGHTUSERDATA;
    }
    private static final int LUA_TNUMBER = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_TNUMBER 3
     * }
     */
    public static int LUA_TNUMBER() {
        return LUA_TNUMBER;
    }
    private static final int LUA_TSTRING = (int)4L;
    /**
     * {@snippet lang=c :
     * #define LUA_TSTRING 4
     * }
     */
    public static int LUA_TSTRING() {
        return LUA_TSTRING;
    }
    private static final int LUA_TTABLE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define LUA_TTABLE 5
     * }
     */
    public static int LUA_TTABLE() {
        return LUA_TTABLE;
    }
    private static final int LUA_TFUNCTION = (int)6L;
    /**
     * {@snippet lang=c :
     * #define LUA_TFUNCTION 6
     * }
     */
    public static int LUA_TFUNCTION() {
        return LUA_TFUNCTION;
    }
    private static final int LUA_TUSERDATA = (int)7L;
    /**
     * {@snippet lang=c :
     * #define LUA_TUSERDATA 7
     * }
     */
    public static int LUA_TUSERDATA() {
        return LUA_TUSERDATA;
    }
    private static final int LUA_TTHREAD = (int)8L;
    /**
     * {@snippet lang=c :
     * #define LUA_TTHREAD 8
     * }
     */
    public static int LUA_TTHREAD() {
        return LUA_TTHREAD;
    }
    private static final int LUA_NUMTYPES = (int)9L;
    /**
     * {@snippet lang=c :
     * #define LUA_NUMTYPES 9
     * }
     */
    public static int LUA_NUMTYPES() {
        return LUA_NUMTYPES;
    }
    private static final int LUA_MINSTACK = (int)20L;
    /**
     * {@snippet lang=c :
     * #define LUA_MINSTACK 20
     * }
     */
    public static int LUA_MINSTACK() {
        return LUA_MINSTACK;
    }
    private static final int LUA_RIDX_MAINTHREAD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_RIDX_MAINTHREAD 1
     * }
     */
    public static int LUA_RIDX_MAINTHREAD() {
        return LUA_RIDX_MAINTHREAD;
    }
    private static final int LUA_RIDX_GLOBALS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_RIDX_GLOBALS 2
     * }
     */
    public static int LUA_RIDX_GLOBALS() {
        return LUA_RIDX_GLOBALS;
    }
    private static final int LUA_OPADD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPADD 0
     * }
     */
    public static int LUA_OPADD() {
        return LUA_OPADD;
    }
    private static final int LUA_OPSUB = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPSUB 1
     * }
     */
    public static int LUA_OPSUB() {
        return LUA_OPSUB;
    }
    private static final int LUA_OPMUL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPMUL 2
     * }
     */
    public static int LUA_OPMUL() {
        return LUA_OPMUL;
    }
    private static final int LUA_OPMOD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPMOD 3
     * }
     */
    public static int LUA_OPMOD() {
        return LUA_OPMOD;
    }
    private static final int LUA_OPPOW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPPOW 4
     * }
     */
    public static int LUA_OPPOW() {
        return LUA_OPPOW;
    }
    private static final int LUA_OPDIV = (int)5L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPDIV 5
     * }
     */
    public static int LUA_OPDIV() {
        return LUA_OPDIV;
    }
    private static final int LUA_OPIDIV = (int)6L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPIDIV 6
     * }
     */
    public static int LUA_OPIDIV() {
        return LUA_OPIDIV;
    }
    private static final int LUA_OPBAND = (int)7L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPBAND 7
     * }
     */
    public static int LUA_OPBAND() {
        return LUA_OPBAND;
    }
    private static final int LUA_OPBOR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPBOR 8
     * }
     */
    public static int LUA_OPBOR() {
        return LUA_OPBOR;
    }
    private static final int LUA_OPBXOR = (int)9L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPBXOR 9
     * }
     */
    public static int LUA_OPBXOR() {
        return LUA_OPBXOR;
    }
    private static final int LUA_OPSHL = (int)10L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPSHL 10
     * }
     */
    public static int LUA_OPSHL() {
        return LUA_OPSHL;
    }
    private static final int LUA_OPSHR = (int)11L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPSHR 11
     * }
     */
    public static int LUA_OPSHR() {
        return LUA_OPSHR;
    }
    private static final int LUA_OPUNM = (int)12L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPUNM 12
     * }
     */
    public static int LUA_OPUNM() {
        return LUA_OPUNM;
    }
    private static final int LUA_OPBNOT = (int)13L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPBNOT 13
     * }
     */
    public static int LUA_OPBNOT() {
        return LUA_OPBNOT;
    }
    private static final int LUA_OPEQ = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPEQ 0
     * }
     */
    public static int LUA_OPEQ() {
        return LUA_OPEQ;
    }
    private static final int LUA_OPLT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPLT 1
     * }
     */
    public static int LUA_OPLT() {
        return LUA_OPLT;
    }
    private static final int LUA_OPLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPLE 2
     * }
     */
    public static int LUA_OPLE() {
        return LUA_OPLE;
    }
    private static final int LUA_GCSTOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCSTOP 0
     * }
     */
    public static int LUA_GCSTOP() {
        return LUA_GCSTOP;
    }
    private static final int LUA_GCRESTART = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCRESTART 1
     * }
     */
    public static int LUA_GCRESTART() {
        return LUA_GCRESTART;
    }
    private static final int LUA_GCCOLLECT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCCOLLECT 2
     * }
     */
    public static int LUA_GCCOLLECT() {
        return LUA_GCCOLLECT;
    }
    private static final int LUA_GCCOUNT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCCOUNT 3
     * }
     */
    public static int LUA_GCCOUNT() {
        return LUA_GCCOUNT;
    }
    private static final int LUA_GCCOUNTB = (int)4L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCCOUNTB 4
     * }
     */
    public static int LUA_GCCOUNTB() {
        return LUA_GCCOUNTB;
    }
    private static final int LUA_GCSTEP = (int)5L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCSTEP 5
     * }
     */
    public static int LUA_GCSTEP() {
        return LUA_GCSTEP;
    }
    private static final int LUA_GCSETPAUSE = (int)6L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCSETPAUSE 6
     * }
     */
    public static int LUA_GCSETPAUSE() {
        return LUA_GCSETPAUSE;
    }
    private static final int LUA_GCSETSTEPMUL = (int)7L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCSETSTEPMUL 7
     * }
     */
    public static int LUA_GCSETSTEPMUL() {
        return LUA_GCSETSTEPMUL;
    }
    private static final int LUA_GCISRUNNING = (int)9L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCISRUNNING 9
     * }
     */
    public static int LUA_GCISRUNNING() {
        return LUA_GCISRUNNING;
    }
    private static final int LUA_GCGEN = (int)10L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCGEN 10
     * }
     */
    public static int LUA_GCGEN() {
        return LUA_GCGEN;
    }
    private static final int LUA_GCINC = (int)11L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCINC 11
     * }
     */
    public static int LUA_GCINC() {
        return LUA_GCINC;
    }
    private static final int LUA_HOOKCALL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_HOOKCALL 0
     * }
     */
    public static int LUA_HOOKCALL() {
        return LUA_HOOKCALL;
    }
    private static final int LUA_HOOKRET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_HOOKRET 1
     * }
     */
    public static int LUA_HOOKRET() {
        return LUA_HOOKRET;
    }
    private static final int LUA_HOOKLINE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_HOOKLINE 2
     * }
     */
    public static int LUA_HOOKLINE() {
        return LUA_HOOKLINE;
    }
    private static final int LUA_HOOKCOUNT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_HOOKCOUNT 3
     * }
     */
    public static int LUA_HOOKCOUNT() {
        return LUA_HOOKCOUNT;
    }
    private static final int LUA_HOOKTAILCALL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define LUA_HOOKTAILCALL 4
     * }
     */
    public static int LUA_HOOKTAILCALL() {
        return LUA_HOOKTAILCALL;
    }
    private static final int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1
     * }
     */
    public static int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE() {
        return _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE;
    }
    private static final int _CRT_BUILD_DESKTOP_APP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_BUILD_DESKTOP_APP 1
     * }
     */
    public static int _CRT_BUILD_DESKTOP_APP() {
        return _CRT_BUILD_DESKTOP_APP;
    }
    private static final int _ARGMAX = (int)100L;
    /**
     * {@snippet lang=c :
     * #define _ARGMAX 100
     * }
     */
    public static int _ARGMAX() {
        return _ARGMAX;
    }
    private static final int _CRT_INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INT_MAX 2147483647
     * }
     */
    public static int _CRT_INT_MAX() {
        return _CRT_INT_MAX;
    }
    private static final int _CRT_FUNCTIONS_REQUIRED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_FUNCTIONS_REQUIRED 1
     * }
     */
    public static int _CRT_FUNCTIONS_REQUIRED() {
        return _CRT_FUNCTIONS_REQUIRED;
    }
    private static final int _CRT_HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_HAS_CXX17 0
     * }
     */
    public static int _CRT_HAS_CXX17() {
        return _CRT_HAS_CXX17;
    }
    private static final int _CRT_HAS_C11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_HAS_C11 1
     * }
     */
    public static int _CRT_HAS_C11() {
        return _CRT_HAS_C11;
    }
    private static final int _CRT_INTERNAL_NONSTDC_NAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_NONSTDC_NAMES 1
     * }
     */
    public static int _CRT_INTERNAL_NONSTDC_NAMES() {
        return _CRT_INTERNAL_NONSTDC_NAMES;
    }
    private static final int __STDC_WANT_SECURE_LIB__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_SECURE_LIB__ 1
     * }
     */
    public static int __STDC_WANT_SECURE_LIB__() {
        return __STDC_WANT_SECURE_LIB__;
    }
    private static final int _SECURECRT_FILL_BUFFER_PATTERN = (int)254L;
    /**
     * {@snippet lang=c :
     * #define _SECURECRT_FILL_BUFFER_PATTERN 254
     * }
     */
    public static int _SECURECRT_FILL_BUFFER_PATTERN() {
        return _SECURECRT_FILL_BUFFER_PATTERN;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 1
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY;
    }
    private static final int BUFSIZ = (int)512L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 512
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int _NSTREAM_ = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _NSTREAM_ 512
     * }
     */
    public static int _NSTREAM_() {
        return _NSTREAM_;
    }
    private static final int _IOB_ENTRIES = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _IOB_ENTRIES 3
     * }
     */
    public static int _IOB_ENTRIES() {
        return _IOB_ENTRIES;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 64
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 4
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int L_tmpnam = (int)260L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 260
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int FILENAME_MAX = (int)260L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 260
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int FOPEN_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 20
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int _SYS_OPEN = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SYS_OPEN 20
     * }
     */
    public static int _SYS_OPEN() {
        return _SYS_OPEN;
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list va_list
     * }
     */
    public static final AddressLayout va_list = luahpp_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = luahpp_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = luahpp_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long size_t
     * }
     */
    public static final OfLong size_t = luahpp_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wchar_t
     * }
     */
    public static final OfShort wchar_t = luahpp_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef double max_align_t
     * }
     */
    public static final OfDouble max_align_t = luahpp_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = luahpp_h.C_LONG_LONG;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __va_start(va_list *, ...)
     * }
     */
    public static class __va_start {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                luahpp_h.C_POINTER
            );
        private static final MemorySegment ADDR = luahpp_h.findOrThrow("__va_start");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __va_start(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __va_start(va_list *, ...)
         * }
         */
        public static __va_start makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __va_start(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__va_start", x0, x1);
                }
                spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long long intptr_t
     * }
     */
    public static final OfLong intptr_t = luahpp_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef _Bool __vcrt_bool
     * }
     */
    public static final OfBoolean __vcrt_bool = luahpp_h.C_BOOL;

    private static class __security_init_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__security_init_cookie"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static FunctionDescriptor __security_init_cookie$descriptor() {
        return __security_init_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MethodHandle __security_init_cookie$handle() {
        return __security_init_cookie.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static void __security_init_cookie() {
        var mh$ = __security_init_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_init_cookie");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_check_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__security_check_cookie"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __security_check_cookie$descriptor() {
        return __security_check_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __security_check_cookie$handle() {
        return __security_check_cookie.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static void __security_check_cookie(long _StackCookie) {
        var mh$ = __security_check_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_check_cookie", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __report_gsfailure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__report_gsfailure"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __report_gsfailure$descriptor() {
        return __report_gsfailure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __report_gsfailure$handle() {
        return __report_gsfailure.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static void __report_gsfailure(long _StackCookie) {
        var mh$ = __report_gsfailure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__report_gsfailure", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_cookie$constants {
        public static final OfLong LAYOUT = luahpp_h.C_LONG_LONG;
        public static final MemorySegment SEGMENT = luahpp_h.findOrThrow("__security_cookie").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static OfLong __security_cookie$layout() {
        return __security_cookie$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static MemorySegment __security_cookie$segment() {
        return __security_cookie$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static long __security_cookie() {
        return __security_cookie$constants.SEGMENT.get(__security_cookie$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static void __security_cookie(long varValue) {
        __security_cookie$constants.SEGMENT.set(__security_cookie$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef double lua_Number
     * }
     */
    public static final OfDouble lua_Number = luahpp_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef long long lua_Integer
     * }
     */
    public static final OfLong lua_Integer = luahpp_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long lua_Unsigned
     * }
     */
    public static final OfLong lua_Unsigned = luahpp_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ptrdiff_t lua_KContext
     * }
     */
    public static final OfLong lua_KContext = luahpp_h.C_LONG_LONG;

    private static class lua_ident$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, luahpp_h.C_CHAR);
        public static final MemorySegment SEGMENT = luahpp_h.findOrThrow("lua_ident").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char lua_ident[]
     * }
     */
    public static SequenceLayout lua_ident$layout() {
        return lua_ident$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char lua_ident[]
     * }
     */
    public static long[] lua_ident$dimensions() {
        return lua_ident$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char lua_ident[]
     * }
     */
    public static MemorySegment lua_ident() {
        return lua_ident$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char lua_ident[]
     * }
     */
    public static void lua_ident(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, lua_ident$constants.SEGMENT, 0L, lua_ident$constants.LAYOUT.byteSize());
    }

    private static class lua_newstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_newstate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_State *(lua_newstate)(lua_Alloc f, void *ud)
     * }
     */
    public static FunctionDescriptor lua_newstate$descriptor() {
        return lua_newstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_State *(lua_newstate)(lua_Alloc f, void *ud)
     * }
     */
    public static MethodHandle lua_newstate$handle() {
        return lua_newstate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_State *(lua_newstate)(lua_Alloc f, void *ud)
     * }
     */
    public static MemorySegment lua_newstate(MemorySegment f, MemorySegment ud) {
        var mh$ = lua_newstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_newstate", f, ud);
            }
            return (MemorySegment)mh$.invokeExact(f, ud);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_close"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_close)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_close$descriptor() {
        return lua_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_close)(lua_State *L)
     * }
     */
    public static MethodHandle lua_close$handle() {
        return lua_close.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_close)(lua_State *L)
     * }
     */
    public static void lua_close(MemorySegment L) {
        var mh$ = lua_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_close", L);
            }
            mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_newthread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_newthread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_State *(lua_newthread)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_newthread$descriptor() {
        return lua_newthread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_State *(lua_newthread)(lua_State *L)
     * }
     */
    public static MethodHandle lua_newthread$handle() {
        return lua_newthread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_State *(lua_newthread)(lua_State *L)
     * }
     */
    public static MemorySegment lua_newthread(MemorySegment L) {
        var mh$ = lua_newthread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_newthread", L);
            }
            return (MemorySegment)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_resetthread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_resetthread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_resetthread)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_resetthread$descriptor() {
        return lua_resetthread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_resetthread)(lua_State *L)
     * }
     */
    public static MethodHandle lua_resetthread$handle() {
        return lua_resetthread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_resetthread)(lua_State *L)
     * }
     */
    public static int lua_resetthread(MemorySegment L) {
        var mh$ = lua_resetthread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_resetthread", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_atpanic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_atpanic"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_CFunction (lua_atpanic)(lua_State *L, lua_CFunction panicf)
     * }
     */
    public static FunctionDescriptor lua_atpanic$descriptor() {
        return lua_atpanic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_CFunction (lua_atpanic)(lua_State *L, lua_CFunction panicf)
     * }
     */
    public static MethodHandle lua_atpanic$handle() {
        return lua_atpanic.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_CFunction (lua_atpanic)(lua_State *L, lua_CFunction panicf)
     * }
     */
    public static MemorySegment lua_atpanic(MemorySegment L, MemorySegment panicf) {
        var mh$ = lua_atpanic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_atpanic", L, panicf);
            }
            return (MemorySegment)mh$.invokeExact(L, panicf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_DOUBLE,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_version"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Number (lua_version)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_version$descriptor() {
        return lua_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Number (lua_version)(lua_State *L)
     * }
     */
    public static MethodHandle lua_version$handle() {
        return lua_version.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Number (lua_version)(lua_State *L)
     * }
     */
    public static double lua_version(MemorySegment L) {
        var mh$ = lua_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_version", L);
            }
            return (double)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_absindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_absindex"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_absindex)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_absindex$descriptor() {
        return lua_absindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_absindex)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_absindex$handle() {
        return lua_absindex.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_absindex)(lua_State *L, int idx)
     * }
     */
    public static int lua_absindex(MemorySegment L, int idx) {
        var mh$ = lua_absindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_absindex", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_gettop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_gettop"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_gettop)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_gettop$descriptor() {
        return lua_gettop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_gettop)(lua_State *L)
     * }
     */
    public static MethodHandle lua_gettop$handle() {
        return lua_gettop.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_gettop)(lua_State *L)
     * }
     */
    public static int lua_gettop(MemorySegment L) {
        var mh$ = lua_gettop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_gettop", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_settop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_settop"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_settop)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_settop$descriptor() {
        return lua_settop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_settop)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_settop$handle() {
        return lua_settop.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_settop)(lua_State *L, int idx)
     * }
     */
    public static void lua_settop(MemorySegment L, int idx) {
        var mh$ = lua_settop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_settop", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushvalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_pushvalue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_pushvalue)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_pushvalue$descriptor() {
        return lua_pushvalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_pushvalue)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_pushvalue$handle() {
        return lua_pushvalue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_pushvalue)(lua_State *L, int idx)
     * }
     */
    public static void lua_pushvalue(MemorySegment L, int idx) {
        var mh$ = lua_pushvalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushvalue", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rotate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_rotate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_rotate)(lua_State *L, int idx, int n)
     * }
     */
    public static FunctionDescriptor lua_rotate$descriptor() {
        return lua_rotate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_rotate)(lua_State *L, int idx, int n)
     * }
     */
    public static MethodHandle lua_rotate$handle() {
        return lua_rotate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_rotate)(lua_State *L, int idx, int n)
     * }
     */
    public static void lua_rotate(MemorySegment L, int idx, int n) {
        var mh$ = lua_rotate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rotate", L, idx, n);
            }
            mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_copy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_copy)(lua_State *L, int fromidx, int toidx)
     * }
     */
    public static FunctionDescriptor lua_copy$descriptor() {
        return lua_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_copy)(lua_State *L, int fromidx, int toidx)
     * }
     */
    public static MethodHandle lua_copy$handle() {
        return lua_copy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_copy)(lua_State *L, int fromidx, int toidx)
     * }
     */
    public static void lua_copy(MemorySegment L, int fromidx, int toidx) {
        var mh$ = lua_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_copy", L, fromidx, toidx);
            }
            mh$.invokeExact(L, fromidx, toidx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_checkstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_checkstack"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_checkstack)(lua_State *L, int n)
     * }
     */
    public static FunctionDescriptor lua_checkstack$descriptor() {
        return lua_checkstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_checkstack)(lua_State *L, int n)
     * }
     */
    public static MethodHandle lua_checkstack$handle() {
        return lua_checkstack.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_checkstack)(lua_State *L, int n)
     * }
     */
    public static int lua_checkstack(MemorySegment L, int n) {
        var mh$ = lua_checkstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_checkstack", L, n);
            }
            return (int)mh$.invokeExact(L, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_xmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_xmove"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_xmove)(lua_State *from, lua_State *to, int n)
     * }
     */
    public static FunctionDescriptor lua_xmove$descriptor() {
        return lua_xmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_xmove)(lua_State *from, lua_State *to, int n)
     * }
     */
    public static MethodHandle lua_xmove$handle() {
        return lua_xmove.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_xmove)(lua_State *from, lua_State *to, int n)
     * }
     */
    public static void lua_xmove(MemorySegment from, MemorySegment to, int n) {
        var mh$ = lua_xmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_xmove", from, to, n);
            }
            mh$.invokeExact(from, to, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_isnumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_isnumber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_isnumber)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_isnumber$descriptor() {
        return lua_isnumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_isnumber)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_isnumber$handle() {
        return lua_isnumber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_isnumber)(lua_State *L, int idx)
     * }
     */
    public static int lua_isnumber(MemorySegment L, int idx) {
        var mh$ = lua_isnumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_isnumber", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_isstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_isstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_isstring)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_isstring$descriptor() {
        return lua_isstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_isstring)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_isstring$handle() {
        return lua_isstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_isstring)(lua_State *L, int idx)
     * }
     */
    public static int lua_isstring(MemorySegment L, int idx) {
        var mh$ = lua_isstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_isstring", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_iscfunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_iscfunction"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_iscfunction)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_iscfunction$descriptor() {
        return lua_iscfunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_iscfunction)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_iscfunction$handle() {
        return lua_iscfunction.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_iscfunction)(lua_State *L, int idx)
     * }
     */
    public static int lua_iscfunction(MemorySegment L, int idx) {
        var mh$ = lua_iscfunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_iscfunction", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_isinteger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_isinteger"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_isinteger)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_isinteger$descriptor() {
        return lua_isinteger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_isinteger)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_isinteger$handle() {
        return lua_isinteger.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_isinteger)(lua_State *L, int idx)
     * }
     */
    public static int lua_isinteger(MemorySegment L, int idx) {
        var mh$ = lua_isinteger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_isinteger", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_isuserdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_isuserdata"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_isuserdata)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_isuserdata$descriptor() {
        return lua_isuserdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_isuserdata)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_isuserdata$handle() {
        return lua_isuserdata.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_isuserdata)(lua_State *L, int idx)
     * }
     */
    public static int lua_isuserdata(MemorySegment L, int idx) {
        var mh$ = lua_isuserdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_isuserdata", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_type"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_type)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_type$descriptor() {
        return lua_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_type)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_type$handle() {
        return lua_type.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_type)(lua_State *L, int idx)
     * }
     */
    public static int lua_type(MemorySegment L, int idx) {
        var mh$ = lua_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_type", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_typename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_typename"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_typename)(lua_State *L, int tp)
     * }
     */
    public static FunctionDescriptor lua_typename$descriptor() {
        return lua_typename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_typename)(lua_State *L, int tp)
     * }
     */
    public static MethodHandle lua_typename$handle() {
        return lua_typename.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_typename)(lua_State *L, int tp)
     * }
     */
    public static MemorySegment lua_typename(MemorySegment L, int tp) {
        var mh$ = lua_typename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_typename", L, tp);
            }
            return (MemorySegment)mh$.invokeExact(L, tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_tonumberx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_DOUBLE,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_tonumberx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Number (lua_tonumberx)(lua_State *L, int idx, int *isnum)
     * }
     */
    public static FunctionDescriptor lua_tonumberx$descriptor() {
        return lua_tonumberx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Number (lua_tonumberx)(lua_State *L, int idx, int *isnum)
     * }
     */
    public static MethodHandle lua_tonumberx$handle() {
        return lua_tonumberx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Number (lua_tonumberx)(lua_State *L, int idx, int *isnum)
     * }
     */
    public static double lua_tonumberx(MemorySegment L, int idx, MemorySegment isnum) {
        var mh$ = lua_tonumberx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_tonumberx", L, idx, isnum);
            }
            return (double)mh$.invokeExact(L, idx, isnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_tointegerx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_tointegerx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Integer (lua_tointegerx)(lua_State *L, int idx, int *isnum)
     * }
     */
    public static FunctionDescriptor lua_tointegerx$descriptor() {
        return lua_tointegerx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Integer (lua_tointegerx)(lua_State *L, int idx, int *isnum)
     * }
     */
    public static MethodHandle lua_tointegerx$handle() {
        return lua_tointegerx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Integer (lua_tointegerx)(lua_State *L, int idx, int *isnum)
     * }
     */
    public static long lua_tointegerx(MemorySegment L, int idx, MemorySegment isnum) {
        var mh$ = lua_tointegerx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_tointegerx", L, idx, isnum);
            }
            return (long)mh$.invokeExact(L, idx, isnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_toboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_toboolean"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_toboolean)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_toboolean$descriptor() {
        return lua_toboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_toboolean)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_toboolean$handle() {
        return lua_toboolean.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_toboolean)(lua_State *L, int idx)
     * }
     */
    public static int lua_toboolean(MemorySegment L, int idx) {
        var mh$ = lua_toboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_toboolean", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_tolstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_tolstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_tolstring)(lua_State *L, int idx, size_t *len)
     * }
     */
    public static FunctionDescriptor lua_tolstring$descriptor() {
        return lua_tolstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_tolstring)(lua_State *L, int idx, size_t *len)
     * }
     */
    public static MethodHandle lua_tolstring$handle() {
        return lua_tolstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_tolstring)(lua_State *L, int idx, size_t *len)
     * }
     */
    public static MemorySegment lua_tolstring(MemorySegment L, int idx, MemorySegment len) {
        var mh$ = lua_tolstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_tolstring", L, idx, len);
            }
            return (MemorySegment)mh$.invokeExact(L, idx, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_rawlen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Unsigned (lua_rawlen)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_rawlen$descriptor() {
        return lua_rawlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Unsigned (lua_rawlen)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_rawlen$handle() {
        return lua_rawlen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Unsigned (lua_rawlen)(lua_State *L, int idx)
     * }
     */
    public static long lua_rawlen(MemorySegment L, int idx) {
        var mh$ = lua_rawlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawlen", L, idx);
            }
            return (long)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_tocfunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_tocfunction"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_CFunction (lua_tocfunction)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_tocfunction$descriptor() {
        return lua_tocfunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_CFunction (lua_tocfunction)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_tocfunction$handle() {
        return lua_tocfunction.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_CFunction (lua_tocfunction)(lua_State *L, int idx)
     * }
     */
    public static MemorySegment lua_tocfunction(MemorySegment L, int idx) {
        var mh$ = lua_tocfunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_tocfunction", L, idx);
            }
            return (MemorySegment)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_touserdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_touserdata"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *(lua_touserdata)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_touserdata$descriptor() {
        return lua_touserdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *(lua_touserdata)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_touserdata$handle() {
        return lua_touserdata.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *(lua_touserdata)(lua_State *L, int idx)
     * }
     */
    public static MemorySegment lua_touserdata(MemorySegment L, int idx) {
        var mh$ = lua_touserdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_touserdata", L, idx);
            }
            return (MemorySegment)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_tothread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_tothread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_State *(lua_tothread)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_tothread$descriptor() {
        return lua_tothread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_State *(lua_tothread)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_tothread$handle() {
        return lua_tothread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_State *(lua_tothread)(lua_State *L, int idx)
     * }
     */
    public static MemorySegment lua_tothread(MemorySegment L, int idx) {
        var mh$ = lua_tothread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_tothread", L, idx);
            }
            return (MemorySegment)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_topointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_topointer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const void *(lua_topointer)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_topointer$descriptor() {
        return lua_topointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const void *(lua_topointer)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_topointer$handle() {
        return lua_topointer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const void *(lua_topointer)(lua_State *L, int idx)
     * }
     */
    public static MemorySegment lua_topointer(MemorySegment L, int idx) {
        var mh$ = lua_topointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_topointer", L, idx);
            }
            return (MemorySegment)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_arith {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_arith"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_arith)(lua_State *L, int op)
     * }
     */
    public static FunctionDescriptor lua_arith$descriptor() {
        return lua_arith.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_arith)(lua_State *L, int op)
     * }
     */
    public static MethodHandle lua_arith$handle() {
        return lua_arith.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_arith)(lua_State *L, int op)
     * }
     */
    public static void lua_arith(MemorySegment L, int op) {
        var mh$ = lua_arith.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_arith", L, op);
            }
            mh$.invokeExact(L, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawequal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_rawequal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_rawequal)(lua_State *L, int idx1, int idx2)
     * }
     */
    public static FunctionDescriptor lua_rawequal$descriptor() {
        return lua_rawequal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_rawequal)(lua_State *L, int idx1, int idx2)
     * }
     */
    public static MethodHandle lua_rawequal$handle() {
        return lua_rawequal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_rawequal)(lua_State *L, int idx1, int idx2)
     * }
     */
    public static int lua_rawequal(MemorySegment L, int idx1, int idx2) {
        var mh$ = lua_rawequal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawequal", L, idx1, idx2);
            }
            return (int)mh$.invokeExact(L, idx1, idx2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_compare"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_compare)(lua_State *L, int idx1, int idx2, int op)
     * }
     */
    public static FunctionDescriptor lua_compare$descriptor() {
        return lua_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_compare)(lua_State *L, int idx1, int idx2, int op)
     * }
     */
    public static MethodHandle lua_compare$handle() {
        return lua_compare.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_compare)(lua_State *L, int idx1, int idx2, int op)
     * }
     */
    public static int lua_compare(MemorySegment L, int idx1, int idx2, int op) {
        var mh$ = lua_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_compare", L, idx1, idx2, op);
            }
            return (int)mh$.invokeExact(L, idx1, idx2, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushnil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_pushnil"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_pushnil)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_pushnil$descriptor() {
        return lua_pushnil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_pushnil)(lua_State *L)
     * }
     */
    public static MethodHandle lua_pushnil$handle() {
        return lua_pushnil.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_pushnil)(lua_State *L)
     * }
     */
    public static void lua_pushnil(MemorySegment L) {
        var mh$ = lua_pushnil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushnil", L);
            }
            mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushnumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_pushnumber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_pushnumber)(lua_State *L, lua_Number n)
     * }
     */
    public static FunctionDescriptor lua_pushnumber$descriptor() {
        return lua_pushnumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_pushnumber)(lua_State *L, lua_Number n)
     * }
     */
    public static MethodHandle lua_pushnumber$handle() {
        return lua_pushnumber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_pushnumber)(lua_State *L, lua_Number n)
     * }
     */
    public static void lua_pushnumber(MemorySegment L, double n) {
        var mh$ = lua_pushnumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushnumber", L, n);
            }
            mh$.invokeExact(L, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushinteger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_pushinteger"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_pushinteger)(lua_State *L, lua_Integer n)
     * }
     */
    public static FunctionDescriptor lua_pushinteger$descriptor() {
        return lua_pushinteger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_pushinteger)(lua_State *L, lua_Integer n)
     * }
     */
    public static MethodHandle lua_pushinteger$handle() {
        return lua_pushinteger.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_pushinteger)(lua_State *L, lua_Integer n)
     * }
     */
    public static void lua_pushinteger(MemorySegment L, long n) {
        var mh$ = lua_pushinteger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushinteger", L, n);
            }
            mh$.invokeExact(L, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushlstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_pushlstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_pushlstring)(lua_State *L, const char *s, size_t len)
     * }
     */
    public static FunctionDescriptor lua_pushlstring$descriptor() {
        return lua_pushlstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_pushlstring)(lua_State *L, const char *s, size_t len)
     * }
     */
    public static MethodHandle lua_pushlstring$handle() {
        return lua_pushlstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_pushlstring)(lua_State *L, const char *s, size_t len)
     * }
     */
    public static MemorySegment lua_pushlstring(MemorySegment L, MemorySegment s, long len) {
        var mh$ = lua_pushlstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushlstring", L, s, len);
            }
            return (MemorySegment)mh$.invokeExact(L, s, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_pushstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_pushstring)(lua_State *L, const char *s)
     * }
     */
    public static FunctionDescriptor lua_pushstring$descriptor() {
        return lua_pushstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_pushstring)(lua_State *L, const char *s)
     * }
     */
    public static MethodHandle lua_pushstring$handle() {
        return lua_pushstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_pushstring)(lua_State *L, const char *s)
     * }
     */
    public static MemorySegment lua_pushstring(MemorySegment L, MemorySegment s) {
        var mh$ = lua_pushstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushstring", L, s);
            }
            return (MemorySegment)mh$.invokeExact(L, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushvfstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_pushvfstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_pushvfstring)(lua_State *L, const char *fmt, va_list argp)
     * }
     */
    public static FunctionDescriptor lua_pushvfstring$descriptor() {
        return lua_pushvfstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_pushvfstring)(lua_State *L, const char *fmt, va_list argp)
     * }
     */
    public static MethodHandle lua_pushvfstring$handle() {
        return lua_pushvfstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_pushvfstring)(lua_State *L, const char *fmt, va_list argp)
     * }
     */
    public static MemorySegment lua_pushvfstring(MemorySegment L, MemorySegment fmt, MemorySegment argp) {
        var mh$ = lua_pushvfstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushvfstring", L, fmt, argp);
            }
            return (MemorySegment)mh$.invokeExact(L, fmt, argp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern const char *(lua_pushfstring)(lua_State *L, const char *fmt, ...)
     * }
     */
    public static class lua_pushfstring {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                luahpp_h.C_POINTER,
                luahpp_h.C_POINTER,
                luahpp_h.C_POINTER
            );
        private static final MemorySegment ADDR = luahpp_h.findOrThrow("lua_pushfstring");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private lua_pushfstring(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern const char *(lua_pushfstring)(lua_State *L, const char *fmt, ...)
         * }
         */
        public static lua_pushfstring makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new lua_pushfstring(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment L, MemorySegment fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("lua_pushfstring", L, fmt, x2);
                }
                return (MemorySegment)spreader.invokeExact(L, fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class lua_pushcclosure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_pushcclosure"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_pushcclosure)(lua_State *L, lua_CFunction fn, int n)
     * }
     */
    public static FunctionDescriptor lua_pushcclosure$descriptor() {
        return lua_pushcclosure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_pushcclosure)(lua_State *L, lua_CFunction fn, int n)
     * }
     */
    public static MethodHandle lua_pushcclosure$handle() {
        return lua_pushcclosure.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_pushcclosure)(lua_State *L, lua_CFunction fn, int n)
     * }
     */
    public static void lua_pushcclosure(MemorySegment L, MemorySegment fn, int n) {
        var mh$ = lua_pushcclosure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushcclosure", L, fn, n);
            }
            mh$.invokeExact(L, fn, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_pushboolean"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_pushboolean)(lua_State *L, int b)
     * }
     */
    public static FunctionDescriptor lua_pushboolean$descriptor() {
        return lua_pushboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_pushboolean)(lua_State *L, int b)
     * }
     */
    public static MethodHandle lua_pushboolean$handle() {
        return lua_pushboolean.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_pushboolean)(lua_State *L, int b)
     * }
     */
    public static void lua_pushboolean(MemorySegment L, int b) {
        var mh$ = lua_pushboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushboolean", L, b);
            }
            mh$.invokeExact(L, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushlightuserdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_pushlightuserdata"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_pushlightuserdata)(lua_State *L, void *p)
     * }
     */
    public static FunctionDescriptor lua_pushlightuserdata$descriptor() {
        return lua_pushlightuserdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_pushlightuserdata)(lua_State *L, void *p)
     * }
     */
    public static MethodHandle lua_pushlightuserdata$handle() {
        return lua_pushlightuserdata.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_pushlightuserdata)(lua_State *L, void *p)
     * }
     */
    public static void lua_pushlightuserdata(MemorySegment L, MemorySegment p) {
        var mh$ = lua_pushlightuserdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushlightuserdata", L, p);
            }
            mh$.invokeExact(L, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushthread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_pushthread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_pushthread)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_pushthread$descriptor() {
        return lua_pushthread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_pushthread)(lua_State *L)
     * }
     */
    public static MethodHandle lua_pushthread$handle() {
        return lua_pushthread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_pushthread)(lua_State *L)
     * }
     */
    public static int lua_pushthread(MemorySegment L) {
        var mh$ = lua_pushthread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushthread", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getglobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_getglobal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_getglobal)(lua_State *L, const char *name)
     * }
     */
    public static FunctionDescriptor lua_getglobal$descriptor() {
        return lua_getglobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_getglobal)(lua_State *L, const char *name)
     * }
     */
    public static MethodHandle lua_getglobal$handle() {
        return lua_getglobal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_getglobal)(lua_State *L, const char *name)
     * }
     */
    public static int lua_getglobal(MemorySegment L, MemorySegment name) {
        var mh$ = lua_getglobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getglobal", L, name);
            }
            return (int)mh$.invokeExact(L, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_gettable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_gettable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_gettable)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_gettable$descriptor() {
        return lua_gettable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_gettable)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_gettable$handle() {
        return lua_gettable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_gettable)(lua_State *L, int idx)
     * }
     */
    public static int lua_gettable(MemorySegment L, int idx) {
        var mh$ = lua_gettable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_gettable", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getfield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_getfield"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_getfield)(lua_State *L, int idx, const char *k)
     * }
     */
    public static FunctionDescriptor lua_getfield$descriptor() {
        return lua_getfield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_getfield)(lua_State *L, int idx, const char *k)
     * }
     */
    public static MethodHandle lua_getfield$handle() {
        return lua_getfield.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_getfield)(lua_State *L, int idx, const char *k)
     * }
     */
    public static int lua_getfield(MemorySegment L, int idx, MemorySegment k) {
        var mh$ = lua_getfield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getfield", L, idx, k);
            }
            return (int)mh$.invokeExact(L, idx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_geti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_geti"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_geti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static FunctionDescriptor lua_geti$descriptor() {
        return lua_geti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_geti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static MethodHandle lua_geti$handle() {
        return lua_geti.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_geti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static int lua_geti(MemorySegment L, int idx, long n) {
        var mh$ = lua_geti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_geti", L, idx, n);
            }
            return (int)mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_rawget"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_rawget)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_rawget$descriptor() {
        return lua_rawget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_rawget)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_rawget$handle() {
        return lua_rawget.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_rawget)(lua_State *L, int idx)
     * }
     */
    public static int lua_rawget(MemorySegment L, int idx) {
        var mh$ = lua_rawget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawget", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawgeti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_rawgeti"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_rawgeti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static FunctionDescriptor lua_rawgeti$descriptor() {
        return lua_rawgeti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_rawgeti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static MethodHandle lua_rawgeti$handle() {
        return lua_rawgeti.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_rawgeti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static int lua_rawgeti(MemorySegment L, int idx, long n) {
        var mh$ = lua_rawgeti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawgeti", L, idx, n);
            }
            return (int)mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawgetp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_rawgetp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_rawgetp)(lua_State *L, int idx, const void *p)
     * }
     */
    public static FunctionDescriptor lua_rawgetp$descriptor() {
        return lua_rawgetp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_rawgetp)(lua_State *L, int idx, const void *p)
     * }
     */
    public static MethodHandle lua_rawgetp$handle() {
        return lua_rawgetp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_rawgetp)(lua_State *L, int idx, const void *p)
     * }
     */
    public static int lua_rawgetp(MemorySegment L, int idx, MemorySegment p) {
        var mh$ = lua_rawgetp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawgetp", L, idx, p);
            }
            return (int)mh$.invokeExact(L, idx, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_createtable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_createtable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_createtable)(lua_State *L, int narr, int nrec)
     * }
     */
    public static FunctionDescriptor lua_createtable$descriptor() {
        return lua_createtable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_createtable)(lua_State *L, int narr, int nrec)
     * }
     */
    public static MethodHandle lua_createtable$handle() {
        return lua_createtable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_createtable)(lua_State *L, int narr, int nrec)
     * }
     */
    public static void lua_createtable(MemorySegment L, int narr, int nrec) {
        var mh$ = lua_createtable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_createtable", L, narr, nrec);
            }
            mh$.invokeExact(L, narr, nrec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_newuserdatauv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_newuserdatauv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *(lua_newuserdatauv)(lua_State *L, size_t sz, int nuvalue)
     * }
     */
    public static FunctionDescriptor lua_newuserdatauv$descriptor() {
        return lua_newuserdatauv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *(lua_newuserdatauv)(lua_State *L, size_t sz, int nuvalue)
     * }
     */
    public static MethodHandle lua_newuserdatauv$handle() {
        return lua_newuserdatauv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *(lua_newuserdatauv)(lua_State *L, size_t sz, int nuvalue)
     * }
     */
    public static MemorySegment lua_newuserdatauv(MemorySegment L, long sz, int nuvalue) {
        var mh$ = lua_newuserdatauv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_newuserdatauv", L, sz, nuvalue);
            }
            return (MemorySegment)mh$.invokeExact(L, sz, nuvalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getmetatable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_getmetatable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_getmetatable)(lua_State *L, int objindex)
     * }
     */
    public static FunctionDescriptor lua_getmetatable$descriptor() {
        return lua_getmetatable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_getmetatable)(lua_State *L, int objindex)
     * }
     */
    public static MethodHandle lua_getmetatable$handle() {
        return lua_getmetatable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_getmetatable)(lua_State *L, int objindex)
     * }
     */
    public static int lua_getmetatable(MemorySegment L, int objindex) {
        var mh$ = lua_getmetatable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getmetatable", L, objindex);
            }
            return (int)mh$.invokeExact(L, objindex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getiuservalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_getiuservalue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_getiuservalue)(lua_State *L, int idx, int n)
     * }
     */
    public static FunctionDescriptor lua_getiuservalue$descriptor() {
        return lua_getiuservalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_getiuservalue)(lua_State *L, int idx, int n)
     * }
     */
    public static MethodHandle lua_getiuservalue$handle() {
        return lua_getiuservalue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_getiuservalue)(lua_State *L, int idx, int n)
     * }
     */
    public static int lua_getiuservalue(MemorySegment L, int idx, int n) {
        var mh$ = lua_getiuservalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getiuservalue", L, idx, n);
            }
            return (int)mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setglobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_setglobal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_setglobal)(lua_State *L, const char *name)
     * }
     */
    public static FunctionDescriptor lua_setglobal$descriptor() {
        return lua_setglobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_setglobal)(lua_State *L, const char *name)
     * }
     */
    public static MethodHandle lua_setglobal$handle() {
        return lua_setglobal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_setglobal)(lua_State *L, const char *name)
     * }
     */
    public static void lua_setglobal(MemorySegment L, MemorySegment name) {
        var mh$ = lua_setglobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setglobal", L, name);
            }
            mh$.invokeExact(L, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_settable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_settable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_settable)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_settable$descriptor() {
        return lua_settable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_settable)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_settable$handle() {
        return lua_settable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_settable)(lua_State *L, int idx)
     * }
     */
    public static void lua_settable(MemorySegment L, int idx) {
        var mh$ = lua_settable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_settable", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setfield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_setfield"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_setfield)(lua_State *L, int idx, const char *k)
     * }
     */
    public static FunctionDescriptor lua_setfield$descriptor() {
        return lua_setfield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_setfield)(lua_State *L, int idx, const char *k)
     * }
     */
    public static MethodHandle lua_setfield$handle() {
        return lua_setfield.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_setfield)(lua_State *L, int idx, const char *k)
     * }
     */
    public static void lua_setfield(MemorySegment L, int idx, MemorySegment k) {
        var mh$ = lua_setfield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setfield", L, idx, k);
            }
            mh$.invokeExact(L, idx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_seti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_seti"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_seti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static FunctionDescriptor lua_seti$descriptor() {
        return lua_seti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_seti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static MethodHandle lua_seti$handle() {
        return lua_seti.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_seti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static void lua_seti(MemorySegment L, int idx, long n) {
        var mh$ = lua_seti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_seti", L, idx, n);
            }
            mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_rawset"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_rawset)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_rawset$descriptor() {
        return lua_rawset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_rawset)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_rawset$handle() {
        return lua_rawset.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_rawset)(lua_State *L, int idx)
     * }
     */
    public static void lua_rawset(MemorySegment L, int idx) {
        var mh$ = lua_rawset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawset", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawseti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_rawseti"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_rawseti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static FunctionDescriptor lua_rawseti$descriptor() {
        return lua_rawseti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_rawseti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static MethodHandle lua_rawseti$handle() {
        return lua_rawseti.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_rawseti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static void lua_rawseti(MemorySegment L, int idx, long n) {
        var mh$ = lua_rawseti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawseti", L, idx, n);
            }
            mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawsetp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_rawsetp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_rawsetp)(lua_State *L, int idx, const void *p)
     * }
     */
    public static FunctionDescriptor lua_rawsetp$descriptor() {
        return lua_rawsetp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_rawsetp)(lua_State *L, int idx, const void *p)
     * }
     */
    public static MethodHandle lua_rawsetp$handle() {
        return lua_rawsetp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_rawsetp)(lua_State *L, int idx, const void *p)
     * }
     */
    public static void lua_rawsetp(MemorySegment L, int idx, MemorySegment p) {
        var mh$ = lua_rawsetp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawsetp", L, idx, p);
            }
            mh$.invokeExact(L, idx, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setmetatable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_setmetatable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_setmetatable)(lua_State *L, int objindex)
     * }
     */
    public static FunctionDescriptor lua_setmetatable$descriptor() {
        return lua_setmetatable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_setmetatable)(lua_State *L, int objindex)
     * }
     */
    public static MethodHandle lua_setmetatable$handle() {
        return lua_setmetatable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_setmetatable)(lua_State *L, int objindex)
     * }
     */
    public static int lua_setmetatable(MemorySegment L, int objindex) {
        var mh$ = lua_setmetatable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setmetatable", L, objindex);
            }
            return (int)mh$.invokeExact(L, objindex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setiuservalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_setiuservalue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_setiuservalue)(lua_State *L, int idx, int n)
     * }
     */
    public static FunctionDescriptor lua_setiuservalue$descriptor() {
        return lua_setiuservalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_setiuservalue)(lua_State *L, int idx, int n)
     * }
     */
    public static MethodHandle lua_setiuservalue$handle() {
        return lua_setiuservalue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_setiuservalue)(lua_State *L, int idx, int n)
     * }
     */
    public static int lua_setiuservalue(MemorySegment L, int idx, int n) {
        var mh$ = lua_setiuservalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setiuservalue", L, idx, n);
            }
            return (int)mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_callk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_callk"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_callk)(lua_State *L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static FunctionDescriptor lua_callk$descriptor() {
        return lua_callk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_callk)(lua_State *L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static MethodHandle lua_callk$handle() {
        return lua_callk.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_callk)(lua_State *L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static void lua_callk(MemorySegment L, int nargs, int nresults, long ctx, MemorySegment k) {
        var mh$ = lua_callk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_callk", L, nargs, nresults, ctx, k);
            }
            mh$.invokeExact(L, nargs, nresults, ctx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pcallk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT,
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_pcallk"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_pcallk)(lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static FunctionDescriptor lua_pcallk$descriptor() {
        return lua_pcallk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_pcallk)(lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static MethodHandle lua_pcallk$handle() {
        return lua_pcallk.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_pcallk)(lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static int lua_pcallk(MemorySegment L, int nargs, int nresults, int errfunc, long ctx, MemorySegment k) {
        var mh$ = lua_pcallk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pcallk", L, nargs, nresults, errfunc, ctx, k);
            }
            return (int)mh$.invokeExact(L, nargs, nresults, errfunc, ctx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_load {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_load"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_load)(lua_State *L, lua_Reader reader, void *dt, const char *chunkname, const char *mode)
     * }
     */
    public static FunctionDescriptor lua_load$descriptor() {
        return lua_load.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_load)(lua_State *L, lua_Reader reader, void *dt, const char *chunkname, const char *mode)
     * }
     */
    public static MethodHandle lua_load$handle() {
        return lua_load.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_load)(lua_State *L, lua_Reader reader, void *dt, const char *chunkname, const char *mode)
     * }
     */
    public static int lua_load(MemorySegment L, MemorySegment reader, MemorySegment dt, MemorySegment chunkname, MemorySegment mode) {
        var mh$ = lua_load.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_load", L, reader, dt, chunkname, mode);
            }
            return (int)mh$.invokeExact(L, reader, dt, chunkname, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_dump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_dump"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_dump)(lua_State *L, lua_Writer writer, void *data, int strip)
     * }
     */
    public static FunctionDescriptor lua_dump$descriptor() {
        return lua_dump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_dump)(lua_State *L, lua_Writer writer, void *data, int strip)
     * }
     */
    public static MethodHandle lua_dump$handle() {
        return lua_dump.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_dump)(lua_State *L, lua_Writer writer, void *data, int strip)
     * }
     */
    public static int lua_dump(MemorySegment L, MemorySegment writer, MemorySegment data, int strip) {
        var mh$ = lua_dump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_dump", L, writer, data, strip);
            }
            return (int)mh$.invokeExact(L, writer, data, strip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_yieldk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_yieldk"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_yieldk)(lua_State *L, int nresults, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static FunctionDescriptor lua_yieldk$descriptor() {
        return lua_yieldk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_yieldk)(lua_State *L, int nresults, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static MethodHandle lua_yieldk$handle() {
        return lua_yieldk.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_yieldk)(lua_State *L, int nresults, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static int lua_yieldk(MemorySegment L, int nresults, long ctx, MemorySegment k) {
        var mh$ = lua_yieldk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_yieldk", L, nresults, ctx, k);
            }
            return (int)mh$.invokeExact(L, nresults, ctx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_resume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_resume"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_resume)(lua_State *L, lua_State *from, int narg, int *nres)
     * }
     */
    public static FunctionDescriptor lua_resume$descriptor() {
        return lua_resume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_resume)(lua_State *L, lua_State *from, int narg, int *nres)
     * }
     */
    public static MethodHandle lua_resume$handle() {
        return lua_resume.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_resume)(lua_State *L, lua_State *from, int narg, int *nres)
     * }
     */
    public static int lua_resume(MemorySegment L, MemorySegment from, int narg, MemorySegment nres) {
        var mh$ = lua_resume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_resume", L, from, narg, nres);
            }
            return (int)mh$.invokeExact(L, from, narg, nres);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_status {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_status"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_status)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_status$descriptor() {
        return lua_status.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_status)(lua_State *L)
     * }
     */
    public static MethodHandle lua_status$handle() {
        return lua_status.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_status)(lua_State *L)
     * }
     */
    public static int lua_status(MemorySegment L) {
        var mh$ = lua_status.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_status", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_isyieldable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_isyieldable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_isyieldable)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_isyieldable$descriptor() {
        return lua_isyieldable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_isyieldable)(lua_State *L)
     * }
     */
    public static MethodHandle lua_isyieldable$handle() {
        return lua_isyieldable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_isyieldable)(lua_State *L)
     * }
     */
    public static int lua_isyieldable(MemorySegment L) {
        var mh$ = lua_isyieldable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_isyieldable", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setwarnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_setwarnf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_setwarnf)(lua_State *L, lua_WarnFunction f, void *ud)
     * }
     */
    public static FunctionDescriptor lua_setwarnf$descriptor() {
        return lua_setwarnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_setwarnf)(lua_State *L, lua_WarnFunction f, void *ud)
     * }
     */
    public static MethodHandle lua_setwarnf$handle() {
        return lua_setwarnf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_setwarnf)(lua_State *L, lua_WarnFunction f, void *ud)
     * }
     */
    public static void lua_setwarnf(MemorySegment L, MemorySegment f, MemorySegment ud) {
        var mh$ = lua_setwarnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setwarnf", L, f, ud);
            }
            mh$.invokeExact(L, f, ud);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_warning {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_warning"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_warning)(lua_State *L, const char *msg, int tocont)
     * }
     */
    public static FunctionDescriptor lua_warning$descriptor() {
        return lua_warning.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_warning)(lua_State *L, const char *msg, int tocont)
     * }
     */
    public static MethodHandle lua_warning$handle() {
        return lua_warning.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_warning)(lua_State *L, const char *msg, int tocont)
     * }
     */
    public static void lua_warning(MemorySegment L, MemorySegment msg, int tocont) {
        var mh$ = lua_warning.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_warning", L, msg, tocont);
            }
            mh$.invokeExact(L, msg, tocont);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int (lua_gc)(lua_State *L, int what, ...)
     * }
     */
    public static class lua_gc {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                luahpp_h.C_INT,
                luahpp_h.C_POINTER,
                luahpp_h.C_INT
            );
        private static final MemorySegment ADDR = luahpp_h.findOrThrow("lua_gc");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private lua_gc(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int (lua_gc)(lua_State *L, int what, ...)
         * }
         */
        public static lua_gc makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new lua_gc(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment L, int what, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("lua_gc", L, what, x2);
                }
                return (int)spreader.invokeExact(L, what, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class lua_error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_error"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_error)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_error$descriptor() {
        return lua_error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_error)(lua_State *L)
     * }
     */
    public static MethodHandle lua_error$handle() {
        return lua_error.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_error)(lua_State *L)
     * }
     */
    public static int lua_error(MemorySegment L) {
        var mh$ = lua_error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_error", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_next"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_next)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_next$descriptor() {
        return lua_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_next)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_next$handle() {
        return lua_next.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_next)(lua_State *L, int idx)
     * }
     */
    public static int lua_next(MemorySegment L, int idx) {
        var mh$ = lua_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_next", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_concat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_concat)(lua_State *L, int n)
     * }
     */
    public static FunctionDescriptor lua_concat$descriptor() {
        return lua_concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_concat)(lua_State *L, int n)
     * }
     */
    public static MethodHandle lua_concat$handle() {
        return lua_concat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_concat)(lua_State *L, int n)
     * }
     */
    public static void lua_concat(MemorySegment L, int n) {
        var mh$ = lua_concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_concat", L, n);
            }
            mh$.invokeExact(L, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_len {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_len"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_len)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_len$descriptor() {
        return lua_len.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_len)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_len$handle() {
        return lua_len.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_len)(lua_State *L, int idx)
     * }
     */
    public static void lua_len(MemorySegment L, int idx) {
        var mh$ = lua_len.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_len", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_stringtonumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_stringtonumber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t (lua_stringtonumber)(lua_State *L, const char *s)
     * }
     */
    public static FunctionDescriptor lua_stringtonumber$descriptor() {
        return lua_stringtonumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t (lua_stringtonumber)(lua_State *L, const char *s)
     * }
     */
    public static MethodHandle lua_stringtonumber$handle() {
        return lua_stringtonumber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t (lua_stringtonumber)(lua_State *L, const char *s)
     * }
     */
    public static long lua_stringtonumber(MemorySegment L, MemorySegment s) {
        var mh$ = lua_stringtonumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_stringtonumber", L, s);
            }
            return (long)mh$.invokeExact(L, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_getallocf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Alloc (lua_getallocf)(lua_State *L, void **ud)
     * }
     */
    public static FunctionDescriptor lua_getallocf$descriptor() {
        return lua_getallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Alloc (lua_getallocf)(lua_State *L, void **ud)
     * }
     */
    public static MethodHandle lua_getallocf$handle() {
        return lua_getallocf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Alloc (lua_getallocf)(lua_State *L, void **ud)
     * }
     */
    public static MemorySegment lua_getallocf(MemorySegment L, MemorySegment ud) {
        var mh$ = lua_getallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getallocf", L, ud);
            }
            return (MemorySegment)mh$.invokeExact(L, ud);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_setallocf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_setallocf)(lua_State *L, lua_Alloc f, void *ud)
     * }
     */
    public static FunctionDescriptor lua_setallocf$descriptor() {
        return lua_setallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_setallocf)(lua_State *L, lua_Alloc f, void *ud)
     * }
     */
    public static MethodHandle lua_setallocf$handle() {
        return lua_setallocf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_setallocf)(lua_State *L, lua_Alloc f, void *ud)
     * }
     */
    public static void lua_setallocf(MemorySegment L, MemorySegment f, MemorySegment ud) {
        var mh$ = lua_setallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setallocf", L, f, ud);
            }
            mh$.invokeExact(L, f, ud);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_toclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_toclose"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_toclose)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_toclose$descriptor() {
        return lua_toclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_toclose)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_toclose$handle() {
        return lua_toclose.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_toclose)(lua_State *L, int idx)
     * }
     */
    public static void lua_toclose(MemorySegment L, int idx) {
        var mh$ = lua_toclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_toclose", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_closeslot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_closeslot"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_closeslot)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_closeslot$descriptor() {
        return lua_closeslot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_closeslot)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_closeslot$handle() {
        return lua_closeslot.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_closeslot)(lua_State *L, int idx)
     * }
     */
    public static void lua_closeslot(MemorySegment L, int idx) {
        var mh$ = lua_closeslot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_closeslot", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_getstack"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_getstack)(lua_State *L, int level, lua_Debug *ar)
     * }
     */
    public static FunctionDescriptor lua_getstack$descriptor() {
        return lua_getstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_getstack)(lua_State *L, int level, lua_Debug *ar)
     * }
     */
    public static MethodHandle lua_getstack$handle() {
        return lua_getstack.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_getstack)(lua_State *L, int level, lua_Debug *ar)
     * }
     */
    public static int lua_getstack(MemorySegment L, int level, MemorySegment ar) {
        var mh$ = lua_getstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getstack", L, level, ar);
            }
            return (int)mh$.invokeExact(L, level, ar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_getinfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_getinfo)(lua_State *L, const char *what, lua_Debug *ar)
     * }
     */
    public static FunctionDescriptor lua_getinfo$descriptor() {
        return lua_getinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_getinfo)(lua_State *L, const char *what, lua_Debug *ar)
     * }
     */
    public static MethodHandle lua_getinfo$handle() {
        return lua_getinfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_getinfo)(lua_State *L, const char *what, lua_Debug *ar)
     * }
     */
    public static int lua_getinfo(MemorySegment L, MemorySegment what, MemorySegment ar) {
        var mh$ = lua_getinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getinfo", L, what, ar);
            }
            return (int)mh$.invokeExact(L, what, ar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getlocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_getlocal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_getlocal)(lua_State *L, const lua_Debug *ar, int n)
     * }
     */
    public static FunctionDescriptor lua_getlocal$descriptor() {
        return lua_getlocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_getlocal)(lua_State *L, const lua_Debug *ar, int n)
     * }
     */
    public static MethodHandle lua_getlocal$handle() {
        return lua_getlocal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_getlocal)(lua_State *L, const lua_Debug *ar, int n)
     * }
     */
    public static MemorySegment lua_getlocal(MemorySegment L, MemorySegment ar, int n) {
        var mh$ = lua_getlocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getlocal", L, ar, n);
            }
            return (MemorySegment)mh$.invokeExact(L, ar, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setlocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_setlocal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_setlocal)(lua_State *L, const lua_Debug *ar, int n)
     * }
     */
    public static FunctionDescriptor lua_setlocal$descriptor() {
        return lua_setlocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_setlocal)(lua_State *L, const lua_Debug *ar, int n)
     * }
     */
    public static MethodHandle lua_setlocal$handle() {
        return lua_setlocal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_setlocal)(lua_State *L, const lua_Debug *ar, int n)
     * }
     */
    public static MemorySegment lua_setlocal(MemorySegment L, MemorySegment ar, int n) {
        var mh$ = lua_setlocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setlocal", L, ar, n);
            }
            return (MemorySegment)mh$.invokeExact(L, ar, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getupvalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_getupvalue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_getupvalue)(lua_State *L, int funcindex, int n)
     * }
     */
    public static FunctionDescriptor lua_getupvalue$descriptor() {
        return lua_getupvalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_getupvalue)(lua_State *L, int funcindex, int n)
     * }
     */
    public static MethodHandle lua_getupvalue$handle() {
        return lua_getupvalue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_getupvalue)(lua_State *L, int funcindex, int n)
     * }
     */
    public static MemorySegment lua_getupvalue(MemorySegment L, int funcindex, int n) {
        var mh$ = lua_getupvalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getupvalue", L, funcindex, n);
            }
            return (MemorySegment)mh$.invokeExact(L, funcindex, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setupvalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_setupvalue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_setupvalue)(lua_State *L, int funcindex, int n)
     * }
     */
    public static FunctionDescriptor lua_setupvalue$descriptor() {
        return lua_setupvalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_setupvalue)(lua_State *L, int funcindex, int n)
     * }
     */
    public static MethodHandle lua_setupvalue$handle() {
        return lua_setupvalue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_setupvalue)(lua_State *L, int funcindex, int n)
     * }
     */
    public static MemorySegment lua_setupvalue(MemorySegment L, int funcindex, int n) {
        var mh$ = lua_setupvalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setupvalue", L, funcindex, n);
            }
            return (MemorySegment)mh$.invokeExact(L, funcindex, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_upvalueid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_upvalueid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *(lua_upvalueid)(lua_State *L, int fidx, int n)
     * }
     */
    public static FunctionDescriptor lua_upvalueid$descriptor() {
        return lua_upvalueid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *(lua_upvalueid)(lua_State *L, int fidx, int n)
     * }
     */
    public static MethodHandle lua_upvalueid$handle() {
        return lua_upvalueid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *(lua_upvalueid)(lua_State *L, int fidx, int n)
     * }
     */
    public static MemorySegment lua_upvalueid(MemorySegment L, int fidx, int n) {
        var mh$ = lua_upvalueid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_upvalueid", L, fidx, n);
            }
            return (MemorySegment)mh$.invokeExact(L, fidx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_upvaluejoin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT,
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_upvaluejoin"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_upvaluejoin)(lua_State *L, int fidx1, int n1, int fidx2, int n2)
     * }
     */
    public static FunctionDescriptor lua_upvaluejoin$descriptor() {
        return lua_upvaluejoin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_upvaluejoin)(lua_State *L, int fidx1, int n1, int fidx2, int n2)
     * }
     */
    public static MethodHandle lua_upvaluejoin$handle() {
        return lua_upvaluejoin.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_upvaluejoin)(lua_State *L, int fidx1, int n1, int fidx2, int n2)
     * }
     */
    public static void lua_upvaluejoin(MemorySegment L, int fidx1, int n1, int fidx2, int n2) {
        var mh$ = lua_upvaluejoin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_upvaluejoin", L, fidx1, n1, fidx2, n2);
            }
            mh$.invokeExact(L, fidx1, n1, fidx2, n2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_sethook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_sethook"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_sethook)(lua_State *L, lua_Hook func, int mask, int count)
     * }
     */
    public static FunctionDescriptor lua_sethook$descriptor() {
        return lua_sethook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_sethook)(lua_State *L, lua_Hook func, int mask, int count)
     * }
     */
    public static MethodHandle lua_sethook$handle() {
        return lua_sethook.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_sethook)(lua_State *L, lua_Hook func, int mask, int count)
     * }
     */
    public static void lua_sethook(MemorySegment L, MemorySegment func, int mask, int count) {
        var mh$ = lua_sethook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_sethook", L, func, mask, count);
            }
            mh$.invokeExact(L, func, mask, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_gethook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_gethook"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Hook (lua_gethook)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_gethook$descriptor() {
        return lua_gethook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Hook (lua_gethook)(lua_State *L)
     * }
     */
    public static MethodHandle lua_gethook$handle() {
        return lua_gethook.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Hook (lua_gethook)(lua_State *L)
     * }
     */
    public static MemorySegment lua_gethook(MemorySegment L) {
        var mh$ = lua_gethook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_gethook", L);
            }
            return (MemorySegment)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_gethookmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_gethookmask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_gethookmask)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_gethookmask$descriptor() {
        return lua_gethookmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_gethookmask)(lua_State *L)
     * }
     */
    public static MethodHandle lua_gethookmask$handle() {
        return lua_gethookmask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_gethookmask)(lua_State *L)
     * }
     */
    public static int lua_gethookmask(MemorySegment L) {
        var mh$ = lua_gethookmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_gethookmask", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_gethookcount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_gethookcount"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_gethookcount)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_gethookcount$descriptor() {
        return lua_gethookcount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_gethookcount)(lua_State *L)
     * }
     */
    public static MethodHandle lua_gethookcount$handle() {
        return lua_gethookcount.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_gethookcount)(lua_State *L)
     * }
     */
    public static int lua_gethookcount(MemorySegment L) {
        var mh$ = lua_gethookcount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_gethookcount", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setcstacklimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("lua_setcstacklimit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_setcstacklimit)(lua_State *L, unsigned int limit)
     * }
     */
    public static FunctionDescriptor lua_setcstacklimit$descriptor() {
        return lua_setcstacklimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_setcstacklimit)(lua_State *L, unsigned int limit)
     * }
     */
    public static MethodHandle lua_setcstacklimit$handle() {
        return lua_setcstacklimit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_setcstacklimit)(lua_State *L, unsigned int limit)
     * }
     */
    public static int lua_setcstacklimit(MemorySegment L, int limit) {
        var mh$ = lua_setcstacklimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setcstacklimit", L, limit);
            }
            return (int)mh$.invokeExact(L, limit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaopen_base"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_base)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_base$descriptor() {
        return luaopen_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_base)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_base$handle() {
        return luaopen_base.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_base)(lua_State *L)
     * }
     */
    public static int luaopen_base(MemorySegment L) {
        var mh$ = luaopen_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_base", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_coroutine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaopen_coroutine"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_coroutine)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_coroutine$descriptor() {
        return luaopen_coroutine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_coroutine)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_coroutine$handle() {
        return luaopen_coroutine.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_coroutine)(lua_State *L)
     * }
     */
    public static int luaopen_coroutine(MemorySegment L) {
        var mh$ = luaopen_coroutine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_coroutine", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaopen_table"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_table)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_table$descriptor() {
        return luaopen_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_table)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_table$handle() {
        return luaopen_table.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_table)(lua_State *L)
     * }
     */
    public static int luaopen_table(MemorySegment L) {
        var mh$ = luaopen_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_table", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_io {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaopen_io"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_io)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_io$descriptor() {
        return luaopen_io.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_io)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_io$handle() {
        return luaopen_io.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_io)(lua_State *L)
     * }
     */
    public static int luaopen_io(MemorySegment L) {
        var mh$ = luaopen_io.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_io", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_os {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaopen_os"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_os)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_os$descriptor() {
        return luaopen_os.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_os)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_os$handle() {
        return luaopen_os.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_os)(lua_State *L)
     * }
     */
    public static int luaopen_os(MemorySegment L) {
        var mh$ = luaopen_os.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_os", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaopen_string"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_string)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_string$descriptor() {
        return luaopen_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_string)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_string$handle() {
        return luaopen_string.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_string)(lua_State *L)
     * }
     */
    public static int luaopen_string(MemorySegment L) {
        var mh$ = luaopen_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_string", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaopen_utf8"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_utf8)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_utf8$descriptor() {
        return luaopen_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_utf8)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_utf8$handle() {
        return luaopen_utf8.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_utf8)(lua_State *L)
     * }
     */
    public static int luaopen_utf8(MemorySegment L) {
        var mh$ = luaopen_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_utf8", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_math {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaopen_math"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_math)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_math$descriptor() {
        return luaopen_math.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_math)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_math$handle() {
        return luaopen_math.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_math)(lua_State *L)
     * }
     */
    public static int luaopen_math(MemorySegment L) {
        var mh$ = luaopen_math.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_math", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_debug {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaopen_debug"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_debug)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_debug$descriptor() {
        return luaopen_debug.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_debug)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_debug$handle() {
        return luaopen_debug.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_debug)(lua_State *L)
     * }
     */
    public static int luaopen_debug(MemorySegment L) {
        var mh$ = luaopen_debug.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_debug", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_package {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaopen_package"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_package)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_package$descriptor() {
        return luaopen_package.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_package)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_package$handle() {
        return luaopen_package.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_package)(lua_State *L)
     * }
     */
    public static int luaopen_package(MemorySegment L) {
        var mh$ = luaopen_package.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_package", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_openlibs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_openlibs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_openlibs)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaL_openlibs$descriptor() {
        return luaL_openlibs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_openlibs)(lua_State *L)
     * }
     */
    public static MethodHandle luaL_openlibs$handle() {
        return luaL_openlibs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_openlibs)(lua_State *L)
     * }
     */
    public static void luaL_openlibs(MemorySegment L) {
        var mh$ = luaL_openlibs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_openlibs", L);
            }
            mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef _Bool __crt_bool
     * }
     */
    public static final OfBoolean __crt_bool = luahpp_h.C_BOOL;

    private static class _invalid_parameter_noinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_invalid_parameter_noinfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo$descriptor() {
        return _invalid_parameter_noinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo$handle() {
        return _invalid_parameter_noinfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static void _invalid_parameter_noinfo() {
        var mh$ = _invalid_parameter_noinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invalid_parameter_noinfo_noreturn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_invalid_parameter_noinfo_noreturn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo_noreturn$descriptor() {
        return _invalid_parameter_noinfo_noreturn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo_noreturn$handle() {
        return _invalid_parameter_noinfo_noreturn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static void _invalid_parameter_noinfo_noreturn() {
        var mh$ = _invalid_parameter_noinfo_noreturn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo_noreturn");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invoke_watson {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_invoke_watson"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static FunctionDescriptor _invoke_watson$descriptor() {
        return _invoke_watson.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MethodHandle _invoke_watson$handle() {
        return _invoke_watson.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static void _invoke_watson(MemorySegment _Expression, MemorySegment _FunctionName, MemorySegment _FileName, int _LineNo, long _Reserved) {
        var mh$ = _invoke_watson.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invoke_watson", _Expression, _FunctionName, _FileName, _LineNo, _Reserved);
            }
            mh$.invokeExact(_Expression, _FunctionName, _FileName, _LineNo, _Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = luahpp_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wint_t
     * }
     */
    public static final OfShort wint_t = luahpp_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wctype_t
     * }
     */
    public static final OfShort wctype_t = luahpp_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef long __time32_t
     * }
     */
    public static final OfInt __time32_t = luahpp_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __time64_t
     * }
     */
    public static final OfLong __time64_t = luahpp_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __crt_locale_pointers *_locale_t
     * }
     */
    public static final AddressLayout _locale_t = luahpp_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __time64_t time_t
     * }
     */
    public static final OfLong time_t = luahpp_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = luahpp_h.C_LONG_LONG;

    private static class __acrt_iob_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__acrt_iob_func"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static FunctionDescriptor __acrt_iob_func$descriptor() {
        return __acrt_iob_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static MethodHandle __acrt_iob_func$handle() {
        return __acrt_iob_func.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static MemorySegment __acrt_iob_func(int _Ix) {
        var mh$ = __acrt_iob_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acrt_iob_func", _Ix);
            }
            return (MemorySegment)mh$.invokeExact(_Ix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_SHORT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fgetwc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetwc$descriptor() {
        return fgetwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static MethodHandle fgetwc$handle() {
        return fgetwc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static short fgetwc(MemorySegment _Stream) {
        var mh$ = fgetwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetwc", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_SHORT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fgetwchar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static FunctionDescriptor _fgetwchar$descriptor() {
        return _fgetwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static MethodHandle _fgetwchar$handle() {
        return _fgetwchar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static short _fgetwchar() {
        var mh$ = _fgetwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetwchar");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_SHORT,
            luahpp_h.C_SHORT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fputwc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputwc$descriptor() {
        return fputwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle fputwc$handle() {
        return fputwc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short fputwc(short _Character, MemorySegment _Stream) {
        var mh$ = fputwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputwc", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_SHORT,
            luahpp_h.C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fputwchar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static FunctionDescriptor _fputwchar$descriptor() {
        return _fputwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static MethodHandle _fputwchar$handle() {
        return _fputwchar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static short _fputwchar(short _Character) {
        var mh$ = _fputwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputwchar", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_SHORT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("getwc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getwc$descriptor() {
        return getwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static MethodHandle getwc$handle() {
        return getwc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static short getwc(MemorySegment _Stream) {
        var mh$ = getwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwc", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_SHORT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("getwchar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static FunctionDescriptor getwchar$descriptor() {
        return getwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static MethodHandle getwchar$handle() {
        return getwchar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static short getwchar() {
        var mh$ = getwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwchar");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fgetws"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetws$descriptor() {
        return fgetws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fgetws$handle() {
        return fgetws.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgetws(MemorySegment _Buffer, int _BufferCount, MemorySegment _Stream) {
        var mh$ = fgetws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetws", _Buffer, _BufferCount, _Stream);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _BufferCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fputws"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputws$descriptor() {
        return fputws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static MethodHandle fputws$handle() {
        return fputws.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static int fputws(MemorySegment _Buffer, MemorySegment _Stream) {
        var mh$ = fputws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputws", _Buffer, _Stream);
            }
            return (int)mh$.invokeExact(_Buffer, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getws_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_getws_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _getws_s$descriptor() {
        return _getws_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _getws_s$handle() {
        return _getws_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _getws_s(MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _getws_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getws_s", _Buffer, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_SHORT,
            luahpp_h.C_SHORT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("putwc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putwc$descriptor() {
        return putwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle putwc$handle() {
        return putwc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short putwc(short _Character, MemorySegment _Stream) {
        var mh$ = putwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putwc", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_SHORT,
            luahpp_h.C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("putwchar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static FunctionDescriptor putwchar$descriptor() {
        return putwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static MethodHandle putwchar$handle() {
        return putwchar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static short putwchar(short _Character) {
        var mh$ = putwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putwchar", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_putws"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _putws$descriptor() {
        return _putws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _putws$handle() {
        return _putws.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static int _putws(MemorySegment _Buffer) {
        var mh$ = _putws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putws", _Buffer);
            }
            return (int)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_SHORT,
            luahpp_h.C_SHORT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("ungetwc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ungetwc$descriptor() {
        return ungetwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle ungetwc$handle() {
        return ungetwc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static short ungetwc(short _Character, MemorySegment _Stream) {
        var mh$ = ungetwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetwc", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_wfdopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfdopen$descriptor() {
        return _wfdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfdopen$handle() {
        return _wfdopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfdopen(int _FileHandle, MemorySegment _Mode) {
        var mh$ = _wfdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfdopen", _FileHandle, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileHandle, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_wfopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfopen$descriptor() {
        return _wfopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfopen$handle() {
        return _wfopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfopen(MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = _wfopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfopen", _FileName, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_wfopen_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfopen_s$descriptor() {
        return _wfopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfopen_s$handle() {
        return _wfopen_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static int _wfopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = _wfopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfopen_s", _Stream, _FileName, _Mode);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfreopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_wfreopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor _wfreopen$descriptor() {
        return _wfreopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle _wfreopen$handle() {
        return _wfreopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment _wfreopen(MemorySegment _FileName, MemorySegment _Mode, MemorySegment _OldStream) {
        var mh$ = _wfreopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfreopen", _FileName, _Mode, _OldStream);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _OldStream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfreopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_wfreopen_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor _wfreopen_s$descriptor() {
        return _wfreopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle _wfreopen_s$handle() {
        return _wfreopen_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static int _wfreopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode, MemorySegment _OldStream) {
        var mh$ = _wfreopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfreopen_s", _Stream, _FileName, _Mode, _OldStream);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode, _OldStream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfsopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_wfsopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static FunctionDescriptor _wfsopen$descriptor() {
        return _wfsopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static MethodHandle _wfsopen$handle() {
        return _wfsopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _wfsopen(MemorySegment _FileName, MemorySegment _Mode, int _ShFlag) {
        var mh$ = _wfsopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfsopen", _FileName, _Mode, _ShFlag);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _ShFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wperror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_wperror"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _wperror$descriptor() {
        return _wperror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle _wperror$handle() {
        return _wperror.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static void _wperror(MemorySegment _ErrorMessage) {
        var mh$ = _wperror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wperror", _ErrorMessage);
            }
            mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wpopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_wpopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wpopen$descriptor() {
        return _wpopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wpopen$handle() {
        return _wpopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wpopen(MemorySegment _Command, MemorySegment _Mode) {
        var mh$ = _wpopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wpopen", _Command, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_Command, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wremove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_wremove"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static FunctionDescriptor _wremove$descriptor() {
        return _wremove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static MethodHandle _wremove$handle() {
        return _wremove.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static int _wremove(MemorySegment _FileName) {
        var mh$ = _wremove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wremove", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_wtempnam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static FunctionDescriptor _wtempnam$descriptor() {
        return _wtempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static MethodHandle _wtempnam$handle() {
        return _wtempnam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static MemorySegment _wtempnam(MemorySegment _Directory, MemorySegment _FilePrefix) {
        var mh$ = _wtempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtempnam", _Directory, _FilePrefix);
            }
            return (MemorySegment)mh$.invokeExact(_Directory, _FilePrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtmpnam_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_wtmpnam_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wtmpnam_s$descriptor() {
        return _wtmpnam_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wtmpnam_s$handle() {
        return _wtmpnam_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _wtmpnam_s(MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _wtmpnam_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtmpnam_s", _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_wtmpnam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _wtmpnam$descriptor() {
        return _wtmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _wtmpnam$handle() {
        return _wtmpnam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wtmpnam(MemorySegment _Buffer) {
        var mh$ = _wtmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtmpnam", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_SHORT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fgetwc_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fgetwc_nolock$descriptor() {
        return _fgetwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fgetwc_nolock$handle() {
        return _fgetwc_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static short _fgetwc_nolock(MemorySegment _Stream) {
        var mh$ = _fgetwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetwc_nolock", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_SHORT,
            luahpp_h.C_SHORT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fputwc_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fputwc_nolock$descriptor() {
        return _fputwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _fputwc_nolock$handle() {
        return _fputwc_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short _fputwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _fputwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputwc_nolock", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_SHORT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_getwc_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getwc_nolock$descriptor() {
        return _getwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _getwc_nolock$handle() {
        return _getwc_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static short _getwc_nolock(MemorySegment _Stream) {
        var mh$ = _getwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getwc_nolock", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_SHORT,
            luahpp_h.C_SHORT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_putwc_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putwc_nolock$descriptor() {
        return _putwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _putwc_nolock$handle() {
        return _putwc_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short _putwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _putwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putwc_nolock", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ungetwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_SHORT,
            luahpp_h.C_SHORT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_ungetwc_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ungetwc_nolock$descriptor() {
        return _ungetwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _ungetwc_nolock$handle() {
        return _ungetwc_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static short _ungetwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _ungetwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ungetwc_nolock", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vfwprintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf$descriptor() {
        return __stdio_common_vfwprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf$handle() {
        return __stdio_common_vfwprintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vfwprintf_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf_s$descriptor() {
        return __stdio_common_vfwprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf_s$handle() {
        return __stdio_common_vfwprintf_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf_s(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf_s", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vfwprintf_p"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf_p$descriptor() {
        return __stdio_common_vfwprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf_p$handle() {
        return __stdio_common_vfwprintf_p.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf_p(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf_p", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vfwscanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwscanf$descriptor() {
        return __stdio_common_vfwscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwscanf$handle() {
        return __stdio_common_vfwscanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwscanf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwscanf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vswprintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf$descriptor() {
        return __stdio_common_vswprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf$handle() {
        return __stdio_common_vswprintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vswprintf_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf_s$descriptor() {
        return __stdio_common_vswprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf_s$handle() {
        return __stdio_common_vswprintf_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf_s", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsnwprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vsnwprintf_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsnwprintf_s$descriptor() {
        return __stdio_common_vsnwprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsnwprintf_s$handle() {
        return __stdio_common_vsnwprintf_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsnwprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, long _MaxCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsnwprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsnwprintf_s", _Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vswprintf_p"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf_p$descriptor() {
        return __stdio_common_vswprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf_p$handle() {
        return __stdio_common_vswprintf_p.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf_p(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf_p", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vswscanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswscanf$descriptor() {
        return __stdio_common_vswscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswscanf$handle() {
        return __stdio_common_vswscanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswscanf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswscanf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long long fpos_t
     * }
     */
    public static final OfLong fpos_t = luahpp_h.C_LONG_LONG;

    private static class _get_stream_buffer_pointers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_get_stream_buffer_pointers"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static FunctionDescriptor _get_stream_buffer_pointers$descriptor() {
        return _get_stream_buffer_pointers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static MethodHandle _get_stream_buffer_pointers$handle() {
        return _get_stream_buffer_pointers.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static int _get_stream_buffer_pointers(MemorySegment _Stream, MemorySegment _Base, MemorySegment _Pointer, MemorySegment _Count) {
        var mh$ = _get_stream_buffer_pointers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_stream_buffer_pointers", _Stream, _Base, _Pointer, _Count);
            }
            return (int)mh$.invokeExact(_Stream, _Base, _Pointer, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("clearerr_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor clearerr_s$descriptor() {
        return clearerr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static MethodHandle clearerr_s$handle() {
        return clearerr_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static int clearerr_s(MemorySegment _Stream) {
        var mh$ = clearerr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_s", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fopen_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static FunctionDescriptor fopen_s$descriptor() {
        return fopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static MethodHandle fopen_s$handle() {
        return fopen_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static int fopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = fopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen_s", _Stream, _FileName, _Mode);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fread_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fread_s$descriptor() {
        return fread_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fread_s$handle() {
        return fread_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fread_s(MemorySegment _Buffer, long _BufferSize, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = fread_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_s", _Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("freopen_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor freopen_s$descriptor() {
        return freopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle freopen_s$handle() {
        return freopen_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static int freopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode, MemorySegment _OldStream) {
        var mh$ = freopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen_s", _Stream, _FileName, _Mode, _OldStream);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode, _OldStream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gets_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("gets_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static FunctionDescriptor gets_s$descriptor() {
        return gets_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MethodHandle gets_s$handle() {
        return gets_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MemorySegment gets_s(MemorySegment _Buffer, long _Size) {
        var mh$ = gets_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gets_s", _Buffer, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("tmpfile_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static FunctionDescriptor tmpfile_s$descriptor() {
        return tmpfile_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static MethodHandle tmpfile_s$handle() {
        return tmpfile_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static int tmpfile_s(MemorySegment _Stream) {
        var mh$ = tmpfile_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile_s", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("tmpnam_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static FunctionDescriptor tmpnam_s$descriptor() {
        return tmpnam_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MethodHandle tmpnam_s$handle() {
        return tmpnam_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static int tmpnam_s(MemorySegment _Buffer, long _Size) {
        var mh$ = tmpnam_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_s", _Buffer, _Size);
            }
            return (int)mh$.invokeExact(_Buffer, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("clearerr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static void clearerr(MemorySegment _Stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fclose"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static int fclose(MemorySegment _Stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcloseall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fcloseall"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static FunctionDescriptor _fcloseall$descriptor() {
        return _fcloseall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static MethodHandle _fcloseall$handle() {
        return _fcloseall.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static int _fcloseall() {
        var mh$ = _fcloseall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcloseall");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fdopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static FunctionDescriptor _fdopen$descriptor() {
        return _fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static MethodHandle _fdopen$handle() {
        return _fdopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static MemorySegment _fdopen(int _FileHandle, MemorySegment _Mode) {
        var mh$ = _fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdopen", _FileHandle, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileHandle, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("feof"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static int feof(MemorySegment _Stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("ferror"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static int ferror(MemorySegment _Stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fflush"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static int fflush(MemorySegment _Stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fgetc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static int fgetc(MemorySegment _Stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fgetchar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static FunctionDescriptor _fgetchar$descriptor() {
        return _fgetchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static MethodHandle _fgetchar$handle() {
        return _fgetchar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static int _fgetchar() {
        var mh$ = _fgetchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fgetpos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static int fgetpos(MemorySegment _Stream, MemorySegment _Position) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", _Stream, _Position);
            }
            return (int)mh$.invokeExact(_Stream, _Position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fgets"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment _Buffer, int _MaxCount, MemorySegment _Stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", _Buffer, _MaxCount, _Stream);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _MaxCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fileno"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fileno$descriptor() {
        return _fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static MethodHandle _fileno$handle() {
        return _fileno.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static int _fileno(MemorySegment _Stream) {
        var mh$ = _fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fileno", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _flushall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_flushall"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static FunctionDescriptor _flushall$descriptor() {
        return _flushall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static MethodHandle _flushall$handle() {
        return _flushall.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static int _flushall() {
        var mh$ = _flushall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_flushall");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static MemorySegment fopen(MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", _FileName, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fputc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static int fputc(int _Character, MemorySegment _Stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fputchar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static FunctionDescriptor _fputchar$descriptor() {
        return _fputchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static MethodHandle _fputchar$handle() {
        return _fputchar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static int _fputchar(int _Character) {
        var mh$ = _fputchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputchar", _Character);
            }
            return (int)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fputs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static int fputs(MemorySegment _Buffer, MemorySegment _Stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", _Buffer, _Stream);
            }
            return (int)mh$.invokeExact(_Buffer, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fread(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("freopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment _FileName, MemorySegment _Mode, MemorySegment _Stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", _FileName, _Mode, _Stream);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fsopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fsopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static FunctionDescriptor _fsopen$descriptor() {
        return _fsopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static MethodHandle _fsopen$handle() {
        return _fsopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _fsopen(MemorySegment _FileName, MemorySegment _Mode, int _ShFlag) {
        var mh$ = _fsopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fsopen", _FileName, _Mode, _ShFlag);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _ShFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fsetpos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static int fsetpos(MemorySegment _Stream, MemorySegment _Position) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", _Stream, _Position);
            }
            return (int)mh$.invokeExact(_Stream, _Position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fseek"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static int fseek(MemorySegment _Stream, int _Offset, int _Origin) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseeki64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fseeki64"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseeki64$descriptor() {
        return _fseeki64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseeki64$handle() {
        return _fseeki64.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static int _fseeki64(MemorySegment _Stream, long _Offset, int _Origin) {
        var mh$ = _fseeki64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseeki64", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("ftell"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static int ftell(MemorySegment _Stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftelli64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_ftelli64"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftelli64$descriptor() {
        return _ftelli64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftelli64$handle() {
        return _ftelli64.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static long _ftelli64(MemorySegment _Stream) {
        var mh$ = _ftelli64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftelli64", _Stream);
            }
            return (long)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fwrite"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fwrite(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("getc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static int getc(MemorySegment _Stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("getchar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getmaxstdio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_getmaxstdio"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static FunctionDescriptor _getmaxstdio$descriptor() {
        return _getmaxstdio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static MethodHandle _getmaxstdio$handle() {
        return _getmaxstdio.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static int _getmaxstdio() {
        var mh$ = _getmaxstdio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getmaxstdio");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_getw"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getw$descriptor() {
        return _getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static MethodHandle _getw$handle() {
        return _getw.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static int _getw(MemorySegment _Stream) {
        var mh$ = _getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getw", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("perror"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static void perror(MemorySegment _ErrorMessage) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", _ErrorMessage);
            }
            mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_pclose"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _pclose$descriptor() {
        return _pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static MethodHandle _pclose$handle() {
        return _pclose.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static int _pclose(MemorySegment _Stream) {
        var mh$ = _pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_pclose", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_popen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static FunctionDescriptor _popen$descriptor() {
        return _popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static MethodHandle _popen$handle() {
        return _popen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static MemorySegment _popen(MemorySegment _Command, MemorySegment _Mode) {
        var mh$ = _popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_popen", _Command, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_Command, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("putc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static int putc(int _Character, MemorySegment _Stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("putchar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static int putchar(int _Character) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", _Character);
            }
            return (int)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("puts"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static int puts(MemorySegment _Buffer) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", _Buffer);
            }
            return (int)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_putw"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putw$descriptor() {
        return _putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static MethodHandle _putw$handle() {
        return _putw.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static int _putw(int _Word, MemorySegment _Stream) {
        var mh$ = _putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putw", _Word, _Stream);
            }
            return (int)mh$.invokeExact(_Word, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("remove"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static int remove(MemorySegment _FileName) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("rename"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static int rename(MemorySegment _OldFileName, MemorySegment _NewFileName) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", _OldFileName, _NewFileName);
            }
            return (int)mh$.invokeExact(_OldFileName, _NewFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_unlink"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static FunctionDescriptor _unlink$descriptor() {
        return _unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static MethodHandle _unlink$handle() {
        return _unlink.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static int _unlink(MemorySegment _FileName) {
        var mh$ = _unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_unlink", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("unlink"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static FunctionDescriptor unlink$descriptor() {
        return unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static MethodHandle unlink$handle() {
        return unlink.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static int unlink(MemorySegment _FileName) {
        var mh$ = unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlink", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("rewind"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static void rewind(MemorySegment _Stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rmtmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_rmtmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static FunctionDescriptor _rmtmp$descriptor() {
        return _rmtmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static MethodHandle _rmtmp$handle() {
        return _rmtmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static int _rmtmp() {
        var mh$ = _rmtmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rmtmp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("setbuf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static void setbuf(MemorySegment _Stream, MemorySegment _Buffer) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", _Stream, _Buffer);
            }
            mh$.invokeExact(_Stream, _Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _setmaxstdio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_setmaxstdio"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static FunctionDescriptor _setmaxstdio$descriptor() {
        return _setmaxstdio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static MethodHandle _setmaxstdio$handle() {
        return _setmaxstdio.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static int _setmaxstdio(int _Maximum) {
        var mh$ = _setmaxstdio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_setmaxstdio", _Maximum);
            }
            return (int)mh$.invokeExact(_Maximum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("setvbuf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static int setvbuf(MemorySegment _Stream, MemorySegment _Buffer, int _Mode, long _Size) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", _Stream, _Buffer, _Mode, _Size);
            }
            return (int)mh$.invokeExact(_Stream, _Buffer, _Mode, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_tempnam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static FunctionDescriptor _tempnam$descriptor() {
        return _tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static MethodHandle _tempnam$handle() {
        return _tempnam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static MemorySegment _tempnam(MemorySegment _DirectoryName, MemorySegment _FilePrefix) {
        var mh$ = _tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_tempnam", _DirectoryName, _FilePrefix);
            }
            return (MemorySegment)mh$.invokeExact(_DirectoryName, _FilePrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("tmpfile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("tmpnam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static MemorySegment tmpnam(MemorySegment _Buffer) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("ungetc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static int ungetc(int _Character, MemorySegment _Stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lock_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_lock_file"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _lock_file$descriptor() {
        return _lock_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static MethodHandle _lock_file$handle() {
        return _lock_file.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static void _lock_file(MemorySegment _Stream) {
        var mh$ = _lock_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lock_file", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _unlock_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_unlock_file"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _unlock_file$descriptor() {
        return _unlock_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static MethodHandle _unlock_file$handle() {
        return _unlock_file.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static void _unlock_file(MemorySegment _Stream) {
        var mh$ = _unlock_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_unlock_file", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fclose_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fclose_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fclose_nolock$descriptor() {
        return _fclose_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fclose_nolock$handle() {
        return _fclose_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static int _fclose_nolock(MemorySegment _Stream) {
        var mh$ = _fclose_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fclose_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fflush_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fflush_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fflush_nolock$descriptor() {
        return _fflush_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fflush_nolock$handle() {
        return _fflush_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static int _fflush_nolock(MemorySegment _Stream) {
        var mh$ = _fflush_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fflush_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fgetc_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fgetc_nolock$descriptor() {
        return _fgetc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fgetc_nolock$handle() {
        return _fgetc_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static int _fgetc_nolock(MemorySegment _Stream) {
        var mh$ = _fgetc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetc_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fputc_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fputc_nolock$descriptor() {
        return _fputc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _fputc_nolock$handle() {
        return _fputc_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _fputc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _fputc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputc_nolock", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fread_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fread_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fread_nolock$descriptor() {
        return _fread_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fread_nolock$handle() {
        return _fread_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fread_nolock(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = _fread_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fread_nolock", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fread_nolock_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fread_nolock_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fread_nolock_s$descriptor() {
        return _fread_nolock_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fread_nolock_s$handle() {
        return _fread_nolock_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fread_nolock_s(MemorySegment _Buffer, long _BufferSize, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = _fread_nolock_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fread_nolock_s", _Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseek_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fseek_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseek_nolock$descriptor() {
        return _fseek_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseek_nolock$handle() {
        return _fseek_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static int _fseek_nolock(MemorySegment _Stream, int _Offset, int _Origin) {
        var mh$ = _fseek_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseek_nolock", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseeki64_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fseeki64_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseeki64_nolock$descriptor() {
        return _fseeki64_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseeki64_nolock$handle() {
        return _fseeki64_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static int _fseeki64_nolock(MemorySegment _Stream, long _Offset, int _Origin) {
        var mh$ = _fseeki64_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseeki64_nolock", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftell_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_ftell_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftell_nolock$descriptor() {
        return _ftell_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftell_nolock$handle() {
        return _ftell_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static int _ftell_nolock(MemorySegment _Stream) {
        var mh$ = _ftell_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftell_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftelli64_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_ftelli64_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftelli64_nolock$descriptor() {
        return _ftelli64_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftelli64_nolock$handle() {
        return _ftelli64_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static long _ftelli64_nolock(MemorySegment _Stream) {
        var mh$ = _ftelli64_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftelli64_nolock", _Stream);
            }
            return (long)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fwrite_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_fwrite_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fwrite_nolock$descriptor() {
        return _fwrite_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fwrite_nolock$handle() {
        return _fwrite_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fwrite_nolock(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = _fwrite_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fwrite_nolock", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_getc_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getc_nolock$descriptor() {
        return _getc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _getc_nolock$handle() {
        return _getc_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static int _getc_nolock(MemorySegment _Stream) {
        var mh$ = _getc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getc_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_putc_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putc_nolock$descriptor() {
        return _putc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _putc_nolock$handle() {
        return _putc_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _putc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _putc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putc_nolock", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ungetc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_ungetc_nolock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ungetc_nolock$descriptor() {
        return _ungetc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _ungetc_nolock$handle() {
        return _ungetc_nolock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _ungetc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _ungetc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ungetc_nolock", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__commode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__p__commode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static FunctionDescriptor __p__commode$descriptor() {
        return __p__commode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static MethodHandle __p__commode$handle() {
        return __p__commode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static MemorySegment __p__commode() {
        var mh$ = __p__commode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__commode");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vfprintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf$descriptor() {
        return __stdio_common_vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf$handle() {
        return __stdio_common_vfprintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vfprintf_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf_s$descriptor() {
        return __stdio_common_vfprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf_s$handle() {
        return __stdio_common_vfprintf_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf_s(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf_s", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vfprintf_p"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf_p$descriptor() {
        return __stdio_common_vfprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf_p$handle() {
        return __stdio_common_vfprintf_p.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf_p(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf_p", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_printf_count_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_set_printf_count_output"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static FunctionDescriptor _set_printf_count_output$descriptor() {
        return _set_printf_count_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static MethodHandle _set_printf_count_output$handle() {
        return _set_printf_count_output.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static int _set_printf_count_output(int _Value) {
        var mh$ = _set_printf_count_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_printf_count_output", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_printf_count_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("_get_printf_count_output"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static FunctionDescriptor _get_printf_count_output$descriptor() {
        return _get_printf_count_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static MethodHandle _get_printf_count_output$handle() {
        return _get_printf_count_output.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static int _get_printf_count_output() {
        var mh$ = _get_printf_count_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_printf_count_output");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vfscanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfscanf$descriptor() {
        return __stdio_common_vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static MethodHandle __stdio_common_vfscanf$handle() {
        return __stdio_common_vfscanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static int __stdio_common_vfscanf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _Arglist) {
        var mh$ = __stdio_common_vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfscanf", _Options, _Stream, _Format, _Locale, _Arglist);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _Arglist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vsprintf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf$descriptor() {
        return __stdio_common_vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf$handle() {
        return __stdio_common_vsprintf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vsprintf_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf_s$descriptor() {
        return __stdio_common_vsprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf_s$handle() {
        return __stdio_common_vsprintf_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf_s", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsnprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vsnprintf_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsnprintf_s$descriptor() {
        return __stdio_common_vsnprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsnprintf_s$handle() {
        return __stdio_common_vsnprintf_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsnprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, long _MaxCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsnprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsnprintf_s", _Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vsprintf_p"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf_p$descriptor() {
        return __stdio_common_vsprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf_p$handle() {
        return __stdio_common_vsprintf_p.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf_p(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf_p", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("__stdio_common_vsscanf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsscanf$descriptor() {
        return __stdio_common_vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsscanf$handle() {
        return __stdio_common_vsscanf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsscanf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsscanf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("tempnam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static MemorySegment tempnam(MemorySegment _Directory, MemorySegment _FilePrefix) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", _Directory, _FilePrefix);
            }
            return (MemorySegment)mh$.invokeExact(_Directory, _FilePrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcloseall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fcloseall"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static FunctionDescriptor fcloseall$descriptor() {
        return fcloseall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static MethodHandle fcloseall$handle() {
        return fcloseall.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static int fcloseall() {
        var mh$ = fcloseall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcloseall");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fdopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static MemorySegment fdopen(int _FileHandle, MemorySegment _Format) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", _FileHandle, _Format);
            }
            return (MemorySegment)mh$.invokeExact(_FileHandle, _Format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fgetchar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static FunctionDescriptor fgetchar$descriptor() {
        return fgetchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static MethodHandle fgetchar$handle() {
        return fgetchar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static int fgetchar() {
        var mh$ = fgetchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fileno"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static int fileno(MemorySegment _Stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flushall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("flushall"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static FunctionDescriptor flushall$descriptor() {
        return flushall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static MethodHandle flushall$handle() {
        return flushall.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static int flushall() {
        var mh$ = flushall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flushall");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("fputchar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static FunctionDescriptor fputchar$descriptor() {
        return fputchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static MethodHandle fputchar$handle() {
        return fputchar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static int fputchar(int _Ch) {
        var mh$ = fputchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputchar", _Ch);
            }
            return (int)mh$.invokeExact(_Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("getw"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static int getw(MemorySegment _Stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("putw"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static int putw(int _Ch, MemorySegment _Stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", _Ch, _Stream);
            }
            return (int)mh$.invokeExact(_Ch, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmtmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("rmtmp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static FunctionDescriptor rmtmp$descriptor() {
        return rmtmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static MethodHandle rmtmp$handle() {
        return rmtmp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static int rmtmp() {
        var mh$ = rmtmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmtmp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_checkversion_ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_DOUBLE,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_checkversion_"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_checkversion_)(lua_State *L, lua_Number ver, size_t sz)
     * }
     */
    public static FunctionDescriptor luaL_checkversion_$descriptor() {
        return luaL_checkversion_.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_checkversion_)(lua_State *L, lua_Number ver, size_t sz)
     * }
     */
    public static MethodHandle luaL_checkversion_$handle() {
        return luaL_checkversion_.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_checkversion_)(lua_State *L, lua_Number ver, size_t sz)
     * }
     */
    public static void luaL_checkversion_(MemorySegment L, double ver, long sz) {
        var mh$ = luaL_checkversion_.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_checkversion_", L, ver, sz);
            }
            mh$.invokeExact(L, ver, sz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_getmetafield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_getmetafield"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaL_getmetafield)(lua_State *L, int obj, const char *e)
     * }
     */
    public static FunctionDescriptor luaL_getmetafield$descriptor() {
        return luaL_getmetafield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaL_getmetafield)(lua_State *L, int obj, const char *e)
     * }
     */
    public static MethodHandle luaL_getmetafield$handle() {
        return luaL_getmetafield.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaL_getmetafield)(lua_State *L, int obj, const char *e)
     * }
     */
    public static int luaL_getmetafield(MemorySegment L, int obj, MemorySegment e) {
        var mh$ = luaL_getmetafield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_getmetafield", L, obj, e);
            }
            return (int)mh$.invokeExact(L, obj, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_callmeta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_callmeta"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaL_callmeta)(lua_State *L, int obj, const char *e)
     * }
     */
    public static FunctionDescriptor luaL_callmeta$descriptor() {
        return luaL_callmeta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaL_callmeta)(lua_State *L, int obj, const char *e)
     * }
     */
    public static MethodHandle luaL_callmeta$handle() {
        return luaL_callmeta.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaL_callmeta)(lua_State *L, int obj, const char *e)
     * }
     */
    public static int luaL_callmeta(MemorySegment L, int obj, MemorySegment e) {
        var mh$ = luaL_callmeta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_callmeta", L, obj, e);
            }
            return (int)mh$.invokeExact(L, obj, e);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_tolstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_tolstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(luaL_tolstring)(lua_State *L, int idx, size_t *len)
     * }
     */
    public static FunctionDescriptor luaL_tolstring$descriptor() {
        return luaL_tolstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(luaL_tolstring)(lua_State *L, int idx, size_t *len)
     * }
     */
    public static MethodHandle luaL_tolstring$handle() {
        return luaL_tolstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(luaL_tolstring)(lua_State *L, int idx, size_t *len)
     * }
     */
    public static MemorySegment luaL_tolstring(MemorySegment L, int idx, MemorySegment len) {
        var mh$ = luaL_tolstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_tolstring", L, idx, len);
            }
            return (MemorySegment)mh$.invokeExact(L, idx, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_argerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_argerror"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaL_argerror)(lua_State *L, int arg, const char *extramsg)
     * }
     */
    public static FunctionDescriptor luaL_argerror$descriptor() {
        return luaL_argerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaL_argerror)(lua_State *L, int arg, const char *extramsg)
     * }
     */
    public static MethodHandle luaL_argerror$handle() {
        return luaL_argerror.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaL_argerror)(lua_State *L, int arg, const char *extramsg)
     * }
     */
    public static int luaL_argerror(MemorySegment L, int arg, MemorySegment extramsg) {
        var mh$ = luaL_argerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_argerror", L, arg, extramsg);
            }
            return (int)mh$.invokeExact(L, arg, extramsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_typeerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_typeerror"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaL_typeerror)(lua_State *L, int arg, const char *tname)
     * }
     */
    public static FunctionDescriptor luaL_typeerror$descriptor() {
        return luaL_typeerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaL_typeerror)(lua_State *L, int arg, const char *tname)
     * }
     */
    public static MethodHandle luaL_typeerror$handle() {
        return luaL_typeerror.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaL_typeerror)(lua_State *L, int arg, const char *tname)
     * }
     */
    public static int luaL_typeerror(MemorySegment L, int arg, MemorySegment tname) {
        var mh$ = luaL_typeerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_typeerror", L, arg, tname);
            }
            return (int)mh$.invokeExact(L, arg, tname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_checklstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_checklstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(luaL_checklstring)(lua_State *L, int arg, size_t *l)
     * }
     */
    public static FunctionDescriptor luaL_checklstring$descriptor() {
        return luaL_checklstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(luaL_checklstring)(lua_State *L, int arg, size_t *l)
     * }
     */
    public static MethodHandle luaL_checklstring$handle() {
        return luaL_checklstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(luaL_checklstring)(lua_State *L, int arg, size_t *l)
     * }
     */
    public static MemorySegment luaL_checklstring(MemorySegment L, int arg, MemorySegment l) {
        var mh$ = luaL_checklstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_checklstring", L, arg, l);
            }
            return (MemorySegment)mh$.invokeExact(L, arg, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_optlstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_optlstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(luaL_optlstring)(lua_State *L, int arg, const char *def, size_t *l)
     * }
     */
    public static FunctionDescriptor luaL_optlstring$descriptor() {
        return luaL_optlstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(luaL_optlstring)(lua_State *L, int arg, const char *def, size_t *l)
     * }
     */
    public static MethodHandle luaL_optlstring$handle() {
        return luaL_optlstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(luaL_optlstring)(lua_State *L, int arg, const char *def, size_t *l)
     * }
     */
    public static MemorySegment luaL_optlstring(MemorySegment L, int arg, MemorySegment def, MemorySegment l) {
        var mh$ = luaL_optlstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_optlstring", L, arg, def, l);
            }
            return (MemorySegment)mh$.invokeExact(L, arg, def, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_checknumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_DOUBLE,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_checknumber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Number (luaL_checknumber)(lua_State *L, int arg)
     * }
     */
    public static FunctionDescriptor luaL_checknumber$descriptor() {
        return luaL_checknumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Number (luaL_checknumber)(lua_State *L, int arg)
     * }
     */
    public static MethodHandle luaL_checknumber$handle() {
        return luaL_checknumber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Number (luaL_checknumber)(lua_State *L, int arg)
     * }
     */
    public static double luaL_checknumber(MemorySegment L, int arg) {
        var mh$ = luaL_checknumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_checknumber", L, arg);
            }
            return (double)mh$.invokeExact(L, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_optnumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_DOUBLE,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_optnumber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Number (luaL_optnumber)(lua_State *L, int arg, lua_Number def)
     * }
     */
    public static FunctionDescriptor luaL_optnumber$descriptor() {
        return luaL_optnumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Number (luaL_optnumber)(lua_State *L, int arg, lua_Number def)
     * }
     */
    public static MethodHandle luaL_optnumber$handle() {
        return luaL_optnumber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Number (luaL_optnumber)(lua_State *L, int arg, lua_Number def)
     * }
     */
    public static double luaL_optnumber(MemorySegment L, int arg, double def) {
        var mh$ = luaL_optnumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_optnumber", L, arg, def);
            }
            return (double)mh$.invokeExact(L, arg, def);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_checkinteger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_checkinteger"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Integer (luaL_checkinteger)(lua_State *L, int arg)
     * }
     */
    public static FunctionDescriptor luaL_checkinteger$descriptor() {
        return luaL_checkinteger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Integer (luaL_checkinteger)(lua_State *L, int arg)
     * }
     */
    public static MethodHandle luaL_checkinteger$handle() {
        return luaL_checkinteger.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Integer (luaL_checkinteger)(lua_State *L, int arg)
     * }
     */
    public static long luaL_checkinteger(MemorySegment L, int arg) {
        var mh$ = luaL_checkinteger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_checkinteger", L, arg);
            }
            return (long)mh$.invokeExact(L, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_optinteger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_optinteger"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Integer (luaL_optinteger)(lua_State *L, int arg, lua_Integer def)
     * }
     */
    public static FunctionDescriptor luaL_optinteger$descriptor() {
        return luaL_optinteger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Integer (luaL_optinteger)(lua_State *L, int arg, lua_Integer def)
     * }
     */
    public static MethodHandle luaL_optinteger$handle() {
        return luaL_optinteger.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Integer (luaL_optinteger)(lua_State *L, int arg, lua_Integer def)
     * }
     */
    public static long luaL_optinteger(MemorySegment L, int arg, long def) {
        var mh$ = luaL_optinteger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_optinteger", L, arg, def);
            }
            return (long)mh$.invokeExact(L, arg, def);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_checkstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_checkstack"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_checkstack)(lua_State *L, int sz, const char *msg)
     * }
     */
    public static FunctionDescriptor luaL_checkstack$descriptor() {
        return luaL_checkstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_checkstack)(lua_State *L, int sz, const char *msg)
     * }
     */
    public static MethodHandle luaL_checkstack$handle() {
        return luaL_checkstack.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_checkstack)(lua_State *L, int sz, const char *msg)
     * }
     */
    public static void luaL_checkstack(MemorySegment L, int sz, MemorySegment msg) {
        var mh$ = luaL_checkstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_checkstack", L, sz, msg);
            }
            mh$.invokeExact(L, sz, msg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_checktype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_checktype"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_checktype)(lua_State *L, int arg, int t)
     * }
     */
    public static FunctionDescriptor luaL_checktype$descriptor() {
        return luaL_checktype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_checktype)(lua_State *L, int arg, int t)
     * }
     */
    public static MethodHandle luaL_checktype$handle() {
        return luaL_checktype.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_checktype)(lua_State *L, int arg, int t)
     * }
     */
    public static void luaL_checktype(MemorySegment L, int arg, int t) {
        var mh$ = luaL_checktype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_checktype", L, arg, t);
            }
            mh$.invokeExact(L, arg, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_checkany {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_checkany"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_checkany)(lua_State *L, int arg)
     * }
     */
    public static FunctionDescriptor luaL_checkany$descriptor() {
        return luaL_checkany.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_checkany)(lua_State *L, int arg)
     * }
     */
    public static MethodHandle luaL_checkany$handle() {
        return luaL_checkany.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_checkany)(lua_State *L, int arg)
     * }
     */
    public static void luaL_checkany(MemorySegment L, int arg) {
        var mh$ = luaL_checkany.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_checkany", L, arg);
            }
            mh$.invokeExact(L, arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_newmetatable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_newmetatable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaL_newmetatable)(lua_State *L, const char *tname)
     * }
     */
    public static FunctionDescriptor luaL_newmetatable$descriptor() {
        return luaL_newmetatable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaL_newmetatable)(lua_State *L, const char *tname)
     * }
     */
    public static MethodHandle luaL_newmetatable$handle() {
        return luaL_newmetatable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaL_newmetatable)(lua_State *L, const char *tname)
     * }
     */
    public static int luaL_newmetatable(MemorySegment L, MemorySegment tname) {
        var mh$ = luaL_newmetatable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_newmetatable", L, tname);
            }
            return (int)mh$.invokeExact(L, tname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_setmetatable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_setmetatable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_setmetatable)(lua_State *L, const char *tname)
     * }
     */
    public static FunctionDescriptor luaL_setmetatable$descriptor() {
        return luaL_setmetatable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_setmetatable)(lua_State *L, const char *tname)
     * }
     */
    public static MethodHandle luaL_setmetatable$handle() {
        return luaL_setmetatable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_setmetatable)(lua_State *L, const char *tname)
     * }
     */
    public static void luaL_setmetatable(MemorySegment L, MemorySegment tname) {
        var mh$ = luaL_setmetatable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_setmetatable", L, tname);
            }
            mh$.invokeExact(L, tname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_testudata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_testudata"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *(luaL_testudata)(lua_State *L, int ud, const char *tname)
     * }
     */
    public static FunctionDescriptor luaL_testudata$descriptor() {
        return luaL_testudata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *(luaL_testudata)(lua_State *L, int ud, const char *tname)
     * }
     */
    public static MethodHandle luaL_testudata$handle() {
        return luaL_testudata.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *(luaL_testudata)(lua_State *L, int ud, const char *tname)
     * }
     */
    public static MemorySegment luaL_testudata(MemorySegment L, int ud, MemorySegment tname) {
        var mh$ = luaL_testudata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_testudata", L, ud, tname);
            }
            return (MemorySegment)mh$.invokeExact(L, ud, tname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_checkudata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_checkudata"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *(luaL_checkudata)(lua_State *L, int ud, const char *tname)
     * }
     */
    public static FunctionDescriptor luaL_checkudata$descriptor() {
        return luaL_checkudata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *(luaL_checkudata)(lua_State *L, int ud, const char *tname)
     * }
     */
    public static MethodHandle luaL_checkudata$handle() {
        return luaL_checkudata.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *(luaL_checkudata)(lua_State *L, int ud, const char *tname)
     * }
     */
    public static MemorySegment luaL_checkudata(MemorySegment L, int ud, MemorySegment tname) {
        var mh$ = luaL_checkudata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_checkudata", L, ud, tname);
            }
            return (MemorySegment)mh$.invokeExact(L, ud, tname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_where {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_where"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_where)(lua_State *L, int lvl)
     * }
     */
    public static FunctionDescriptor luaL_where$descriptor() {
        return luaL_where.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_where)(lua_State *L, int lvl)
     * }
     */
    public static MethodHandle luaL_where$handle() {
        return luaL_where.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_where)(lua_State *L, int lvl)
     * }
     */
    public static void luaL_where(MemorySegment L, int lvl) {
        var mh$ = luaL_where.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_where", L, lvl);
            }
            mh$.invokeExact(L, lvl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int (luaL_error)(lua_State *L, const char *fmt, ...)
     * }
     */
    public static class luaL_error {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                luahpp_h.C_INT,
                luahpp_h.C_POINTER,
                luahpp_h.C_POINTER
            );
        private static final MemorySegment ADDR = luahpp_h.findOrThrow("luaL_error");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private luaL_error(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int (luaL_error)(lua_State *L, const char *fmt, ...)
         * }
         */
        public static luaL_error makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new luaL_error(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment L, MemorySegment fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("luaL_error", L, fmt, x2);
                }
                return (int)spreader.invokeExact(L, fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class luaL_checkoption {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_checkoption"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaL_checkoption)(lua_State *L, int arg, const char *def, const char *const lst[])
     * }
     */
    public static FunctionDescriptor luaL_checkoption$descriptor() {
        return luaL_checkoption.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaL_checkoption)(lua_State *L, int arg, const char *def, const char *const lst[])
     * }
     */
    public static MethodHandle luaL_checkoption$handle() {
        return luaL_checkoption.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaL_checkoption)(lua_State *L, int arg, const char *def, const char *const lst[])
     * }
     */
    public static int luaL_checkoption(MemorySegment L, int arg, MemorySegment def, MemorySegment lst) {
        var mh$ = luaL_checkoption.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_checkoption", L, arg, def, lst);
            }
            return (int)mh$.invokeExact(L, arg, def, lst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_fileresult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_fileresult"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaL_fileresult)(lua_State *L, int stat, const char *fname)
     * }
     */
    public static FunctionDescriptor luaL_fileresult$descriptor() {
        return luaL_fileresult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaL_fileresult)(lua_State *L, int stat, const char *fname)
     * }
     */
    public static MethodHandle luaL_fileresult$handle() {
        return luaL_fileresult.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaL_fileresult)(lua_State *L, int stat, const char *fname)
     * }
     */
    public static int luaL_fileresult(MemorySegment L, int stat, MemorySegment fname) {
        var mh$ = luaL_fileresult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_fileresult", L, stat, fname);
            }
            return (int)mh$.invokeExact(L, stat, fname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_execresult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_execresult"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaL_execresult)(lua_State *L, int stat)
     * }
     */
    public static FunctionDescriptor luaL_execresult$descriptor() {
        return luaL_execresult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaL_execresult)(lua_State *L, int stat)
     * }
     */
    public static MethodHandle luaL_execresult$handle() {
        return luaL_execresult.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaL_execresult)(lua_State *L, int stat)
     * }
     */
    public static int luaL_execresult(MemorySegment L, int stat) {
        var mh$ = luaL_execresult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_execresult", L, stat);
            }
            return (int)mh$.invokeExact(L, stat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_ref"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaL_ref)(lua_State *L, int t)
     * }
     */
    public static FunctionDescriptor luaL_ref$descriptor() {
        return luaL_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaL_ref)(lua_State *L, int t)
     * }
     */
    public static MethodHandle luaL_ref$handle() {
        return luaL_ref.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaL_ref)(lua_State *L, int t)
     * }
     */
    public static int luaL_ref(MemorySegment L, int t) {
        var mh$ = luaL_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_ref", L, t);
            }
            return (int)mh$.invokeExact(L, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_unref"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_unref)(lua_State *L, int t, int ref)
     * }
     */
    public static FunctionDescriptor luaL_unref$descriptor() {
        return luaL_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_unref)(lua_State *L, int t, int ref)
     * }
     */
    public static MethodHandle luaL_unref$handle() {
        return luaL_unref.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_unref)(lua_State *L, int t, int ref)
     * }
     */
    public static void luaL_unref(MemorySegment L, int t, int ref) {
        var mh$ = luaL_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_unref", L, t, ref);
            }
            mh$.invokeExact(L, t, ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_loadfilex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_loadfilex"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaL_loadfilex)(lua_State *L, const char *filename, const char *mode)
     * }
     */
    public static FunctionDescriptor luaL_loadfilex$descriptor() {
        return luaL_loadfilex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaL_loadfilex)(lua_State *L, const char *filename, const char *mode)
     * }
     */
    public static MethodHandle luaL_loadfilex$handle() {
        return luaL_loadfilex.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaL_loadfilex)(lua_State *L, const char *filename, const char *mode)
     * }
     */
    public static int luaL_loadfilex(MemorySegment L, MemorySegment filename, MemorySegment mode) {
        var mh$ = luaL_loadfilex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_loadfilex", L, filename, mode);
            }
            return (int)mh$.invokeExact(L, filename, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_loadbufferx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_loadbufferx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaL_loadbufferx)(lua_State *L, const char *buff, size_t sz, const char *name, const char *mode)
     * }
     */
    public static FunctionDescriptor luaL_loadbufferx$descriptor() {
        return luaL_loadbufferx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaL_loadbufferx)(lua_State *L, const char *buff, size_t sz, const char *name, const char *mode)
     * }
     */
    public static MethodHandle luaL_loadbufferx$handle() {
        return luaL_loadbufferx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaL_loadbufferx)(lua_State *L, const char *buff, size_t sz, const char *name, const char *mode)
     * }
     */
    public static int luaL_loadbufferx(MemorySegment L, MemorySegment buff, long sz, MemorySegment name, MemorySegment mode) {
        var mh$ = luaL_loadbufferx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_loadbufferx", L, buff, sz, name, mode);
            }
            return (int)mh$.invokeExact(L, buff, sz, name, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_loadstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_loadstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaL_loadstring)(lua_State *L, const char *s)
     * }
     */
    public static FunctionDescriptor luaL_loadstring$descriptor() {
        return luaL_loadstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaL_loadstring)(lua_State *L, const char *s)
     * }
     */
    public static MethodHandle luaL_loadstring$handle() {
        return luaL_loadstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaL_loadstring)(lua_State *L, const char *s)
     * }
     */
    public static int luaL_loadstring(MemorySegment L, MemorySegment s) {
        var mh$ = luaL_loadstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_loadstring", L, s);
            }
            return (int)mh$.invokeExact(L, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_newstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_newstate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_State *(luaL_newstate)()
     * }
     */
    public static FunctionDescriptor luaL_newstate$descriptor() {
        return luaL_newstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_State *(luaL_newstate)()
     * }
     */
    public static MethodHandle luaL_newstate$handle() {
        return luaL_newstate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_State *(luaL_newstate)()
     * }
     */
    public static MemorySegment luaL_newstate() {
        var mh$ = luaL_newstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_newstate");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_len {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_LONG_LONG,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_len"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Integer (luaL_len)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor luaL_len$descriptor() {
        return luaL_len.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Integer (luaL_len)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle luaL_len$handle() {
        return luaL_len.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Integer (luaL_len)(lua_State *L, int idx)
     * }
     */
    public static long luaL_len(MemorySegment L, int idx) {
        var mh$ = luaL_len.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_len", L, idx);
            }
            return (long)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_addgsub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_addgsub"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_addgsub)(luaL_Buffer *b, const char *s, const char *p, const char *r)
     * }
     */
    public static FunctionDescriptor luaL_addgsub$descriptor() {
        return luaL_addgsub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_addgsub)(luaL_Buffer *b, const char *s, const char *p, const char *r)
     * }
     */
    public static MethodHandle luaL_addgsub$handle() {
        return luaL_addgsub.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_addgsub)(luaL_Buffer *b, const char *s, const char *p, const char *r)
     * }
     */
    public static void luaL_addgsub(MemorySegment b, MemorySegment s, MemorySegment p, MemorySegment r) {
        var mh$ = luaL_addgsub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_addgsub", b, s, p, r);
            }
            mh$.invokeExact(b, s, p, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_gsub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_gsub"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(luaL_gsub)(lua_State *L, const char *s, const char *p, const char *r)
     * }
     */
    public static FunctionDescriptor luaL_gsub$descriptor() {
        return luaL_gsub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(luaL_gsub)(lua_State *L, const char *s, const char *p, const char *r)
     * }
     */
    public static MethodHandle luaL_gsub$handle() {
        return luaL_gsub.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(luaL_gsub)(lua_State *L, const char *s, const char *p, const char *r)
     * }
     */
    public static MemorySegment luaL_gsub(MemorySegment L, MemorySegment s, MemorySegment p, MemorySegment r) {
        var mh$ = luaL_gsub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_gsub", L, s, p, r);
            }
            return (MemorySegment)mh$.invokeExact(L, s, p, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_setfuncs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_setfuncs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_setfuncs)(lua_State *L, const luaL_Reg *l, int nup)
     * }
     */
    public static FunctionDescriptor luaL_setfuncs$descriptor() {
        return luaL_setfuncs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_setfuncs)(lua_State *L, const luaL_Reg *l, int nup)
     * }
     */
    public static MethodHandle luaL_setfuncs$handle() {
        return luaL_setfuncs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_setfuncs)(lua_State *L, const luaL_Reg *l, int nup)
     * }
     */
    public static void luaL_setfuncs(MemorySegment L, MemorySegment l, int nup) {
        var mh$ = luaL_setfuncs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_setfuncs", L, l, nup);
            }
            mh$.invokeExact(L, l, nup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_getsubtable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_INT,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_getsubtable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaL_getsubtable)(lua_State *L, int idx, const char *fname)
     * }
     */
    public static FunctionDescriptor luaL_getsubtable$descriptor() {
        return luaL_getsubtable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaL_getsubtable)(lua_State *L, int idx, const char *fname)
     * }
     */
    public static MethodHandle luaL_getsubtable$handle() {
        return luaL_getsubtable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaL_getsubtable)(lua_State *L, int idx, const char *fname)
     * }
     */
    public static int luaL_getsubtable(MemorySegment L, int idx, MemorySegment fname) {
        var mh$ = luaL_getsubtable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_getsubtable", L, idx, fname);
            }
            return (int)mh$.invokeExact(L, idx, fname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_traceback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_traceback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_traceback)(lua_State *L, lua_State *L1, const char *msg, int level)
     * }
     */
    public static FunctionDescriptor luaL_traceback$descriptor() {
        return luaL_traceback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_traceback)(lua_State *L, lua_State *L1, const char *msg, int level)
     * }
     */
    public static MethodHandle luaL_traceback$handle() {
        return luaL_traceback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_traceback)(lua_State *L, lua_State *L1, const char *msg, int level)
     * }
     */
    public static void luaL_traceback(MemorySegment L, MemorySegment L1, MemorySegment msg, int level) {
        var mh$ = luaL_traceback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_traceback", L, L1, msg, level);
            }
            mh$.invokeExact(L, L1, msg, level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_requiref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_requiref"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_requiref)(lua_State *L, const char *modname, lua_CFunction openf, int glb)
     * }
     */
    public static FunctionDescriptor luaL_requiref$descriptor() {
        return luaL_requiref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_requiref)(lua_State *L, const char *modname, lua_CFunction openf, int glb)
     * }
     */
    public static MethodHandle luaL_requiref$handle() {
        return luaL_requiref.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_requiref)(lua_State *L, const char *modname, lua_CFunction openf, int glb)
     * }
     */
    public static void luaL_requiref(MemorySegment L, MemorySegment modname, MemorySegment openf, int glb) {
        var mh$ = luaL_requiref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_requiref", L, modname, openf, glb);
            }
            mh$.invokeExact(L, modname, openf, glb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_buffinit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_buffinit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_buffinit)(lua_State *L, luaL_Buffer *B)
     * }
     */
    public static FunctionDescriptor luaL_buffinit$descriptor() {
        return luaL_buffinit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_buffinit)(lua_State *L, luaL_Buffer *B)
     * }
     */
    public static MethodHandle luaL_buffinit$handle() {
        return luaL_buffinit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_buffinit)(lua_State *L, luaL_Buffer *B)
     * }
     */
    public static void luaL_buffinit(MemorySegment L, MemorySegment B) {
        var mh$ = luaL_buffinit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_buffinit", L, B);
            }
            mh$.invokeExact(L, B);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_prepbuffsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_prepbuffsize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *(luaL_prepbuffsize)(luaL_Buffer *B, size_t sz)
     * }
     */
    public static FunctionDescriptor luaL_prepbuffsize$descriptor() {
        return luaL_prepbuffsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *(luaL_prepbuffsize)(luaL_Buffer *B, size_t sz)
     * }
     */
    public static MethodHandle luaL_prepbuffsize$handle() {
        return luaL_prepbuffsize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *(luaL_prepbuffsize)(luaL_Buffer *B, size_t sz)
     * }
     */
    public static MemorySegment luaL_prepbuffsize(MemorySegment B, long sz) {
        var mh$ = luaL_prepbuffsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_prepbuffsize", B, sz);
            }
            return (MemorySegment)mh$.invokeExact(B, sz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_addlstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_addlstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_addlstring)(luaL_Buffer *B, const char *s, size_t l)
     * }
     */
    public static FunctionDescriptor luaL_addlstring$descriptor() {
        return luaL_addlstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_addlstring)(luaL_Buffer *B, const char *s, size_t l)
     * }
     */
    public static MethodHandle luaL_addlstring$handle() {
        return luaL_addlstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_addlstring)(luaL_Buffer *B, const char *s, size_t l)
     * }
     */
    public static void luaL_addlstring(MemorySegment B, MemorySegment s, long l) {
        var mh$ = luaL_addlstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_addlstring", B, s, l);
            }
            mh$.invokeExact(B, s, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_addstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_addstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_addstring)(luaL_Buffer *B, const char *s)
     * }
     */
    public static FunctionDescriptor luaL_addstring$descriptor() {
        return luaL_addstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_addstring)(luaL_Buffer *B, const char *s)
     * }
     */
    public static MethodHandle luaL_addstring$handle() {
        return luaL_addstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_addstring)(luaL_Buffer *B, const char *s)
     * }
     */
    public static void luaL_addstring(MemorySegment B, MemorySegment s) {
        var mh$ = luaL_addstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_addstring", B, s);
            }
            mh$.invokeExact(B, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_addvalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_addvalue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_addvalue)(luaL_Buffer *B)
     * }
     */
    public static FunctionDescriptor luaL_addvalue$descriptor() {
        return luaL_addvalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_addvalue)(luaL_Buffer *B)
     * }
     */
    public static MethodHandle luaL_addvalue$handle() {
        return luaL_addvalue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_addvalue)(luaL_Buffer *B)
     * }
     */
    public static void luaL_addvalue(MemorySegment B) {
        var mh$ = luaL_addvalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_addvalue", B);
            }
            mh$.invokeExact(B);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_pushresult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_pushresult"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_pushresult)(luaL_Buffer *B)
     * }
     */
    public static FunctionDescriptor luaL_pushresult$descriptor() {
        return luaL_pushresult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_pushresult)(luaL_Buffer *B)
     * }
     */
    public static MethodHandle luaL_pushresult$handle() {
        return luaL_pushresult.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_pushresult)(luaL_Buffer *B)
     * }
     */
    public static void luaL_pushresult(MemorySegment B) {
        var mh$ = luaL_pushresult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_pushresult", B);
            }
            mh$.invokeExact(B);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_pushresultsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_pushresultsize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_pushresultsize)(luaL_Buffer *B, size_t sz)
     * }
     */
    public static FunctionDescriptor luaL_pushresultsize$descriptor() {
        return luaL_pushresultsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_pushresultsize)(luaL_Buffer *B, size_t sz)
     * }
     */
    public static MethodHandle luaL_pushresultsize$handle() {
        return luaL_pushresultsize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_pushresultsize)(luaL_Buffer *B, size_t sz)
     * }
     */
    public static void luaL_pushresultsize(MemorySegment B, long sz) {
        var mh$ = luaL_pushresultsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_pushresultsize", B, sz);
            }
            mh$.invokeExact(B, sz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_buffinitsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_POINTER,
            luahpp_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    luahpp_h.findOrThrow("luaL_buffinitsize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *(luaL_buffinitsize)(lua_State *L, luaL_Buffer *B, size_t sz)
     * }
     */
    public static FunctionDescriptor luaL_buffinitsize$descriptor() {
        return luaL_buffinitsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *(luaL_buffinitsize)(lua_State *L, luaL_Buffer *B, size_t sz)
     * }
     */
    public static MethodHandle luaL_buffinitsize$handle() {
        return luaL_buffinitsize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern char *(luaL_buffinitsize)(lua_State *L, luaL_Buffer *B, size_t sz)
     * }
     */
    public static MemorySegment luaL_buffinitsize(MemorySegment L, MemorySegment B, long sz) {
        var mh$ = luaL_buffinitsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_buffinitsize", L, B, sz);
            }
            return (MemorySegment)mh$.invokeExact(L, B, sz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int _VCRUNTIME_DISABLED_WARNINGS = (int)4514L;
    /**
     * {@snippet lang=c :
     * #define _VCRUNTIME_DISABLED_WARNINGS 4514
     * }
     */
    public static int _VCRUNTIME_DISABLED_WARNINGS() {
        return _VCRUNTIME_DISABLED_WARNINGS;
    }
    private static final int SCHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MIN -128
     * }
     */
    public static int SCHAR_MIN() {
        return SCHAR_MIN;
    }
    private static final int CHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MIN -128
     * }
     */
    public static int CHAR_MIN() {
        return CHAR_MIN;
    }
    private static final int CHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MAX 127
     * }
     */
    public static int CHAR_MAX() {
        return CHAR_MAX;
    }
    private static final int SHRT_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MIN -32768
     * }
     */
    public static int SHRT_MIN() {
        return SHRT_MIN;
    }
    private static final int INT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_MIN -2147483648
     * }
     */
    public static int INT_MIN() {
        return INT_MIN;
    }
    private static final int UINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_MAX 4294967295
     * }
     */
    public static int UINT_MAX() {
        return UINT_MAX;
    }
    private static final int LONG_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define LONG_MIN -2147483648
     * }
     */
    public static int LONG_MIN() {
        return LONG_MIN;
    }
    private static final int LONG_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define LONG_MAX 2147483647
     * }
     */
    public static int LONG_MAX() {
        return LONG_MAX;
    }
    private static final int ULONG_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define ULONG_MAX 4294967295
     * }
     */
    public static int ULONG_MAX() {
        return ULONG_MAX;
    }
    private static final long LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MAX 9223372036854775807
     * }
     */
    public static long LLONG_MAX() {
        return LLONG_MAX;
    }
    private static final long LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MIN -9223372036854775808
     * }
     */
    public static long LLONG_MIN() {
        return LLONG_MIN;
    }
    private static final long ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULLONG_MAX -1
     * }
     */
    public static long ULLONG_MAX() {
        return ULLONG_MAX;
    }
    private static final int _I8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define _I8_MIN -128
     * }
     */
    public static int _I8_MIN() {
        return _I8_MIN;
    }
    private static final byte _I8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define _I8_MAX 127
     * }
     */
    public static byte _I8_MAX() {
        return _I8_MAX;
    }
    private static final byte _UI8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define _UI8_MAX 255
     * }
     */
    public static byte _UI8_MAX() {
        return _UI8_MAX;
    }
    private static final int _I16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define _I16_MIN -32768
     * }
     */
    public static int _I16_MIN() {
        return _I16_MIN;
    }
    private static final short _I16_MAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define _I16_MAX 32767
     * }
     */
    public static short _I16_MAX() {
        return _I16_MAX;
    }
    private static final short _UI16_MAX = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define _UI16_MAX 65535
     * }
     */
    public static short _UI16_MAX() {
        return _UI16_MAX;
    }
    private static final int _I32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define _I32_MIN -2147483648
     * }
     */
    public static int _I32_MIN() {
        return _I32_MIN;
    }
    private static final int _I32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _I32_MAX 2147483647
     * }
     */
    public static int _I32_MAX() {
        return _I32_MAX;
    }
    private static final int _UI32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define _UI32_MAX 4294967295
     * }
     */
    public static int _UI32_MAX() {
        return _UI32_MAX;
    }
    private static final long _I64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define _I64_MIN -9223372036854775808
     * }
     */
    public static long _I64_MIN() {
        return _I64_MIN;
    }
    private static final long _I64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define _I64_MAX 9223372036854775807
     * }
     */
    public static long _I64_MAX() {
        return _I64_MAX;
    }
    private static final long _UI64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define _UI64_MAX -1
     * }
     */
    public static long _UI64_MAX() {
        return _UI64_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long LONG_LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_LONG_MAX() {
        return LONG_LONG_MAX;
    }
    private static final long LONG_LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_LONG_MIN() {
        return LONG_LONG_MIN;
    }
    private static final long ULONG_LONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_LONG_MAX -1
     * }
     */
    public static long ULONG_LONG_MAX() {
        return ULONG_LONG_MAX;
    }
    private static final int LUAI_IS32INT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUAI_IS32INT 1
     * }
     */
    public static int LUAI_IS32INT() {
        return LUAI_IS32INT;
    }
    private static final int LUA_INT_DEFAULT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_INT_DEFAULT 3
     * }
     */
    public static int LUA_INT_DEFAULT() {
        return LUA_INT_DEFAULT;
    }
    private static final int LUA_FLOAT_DEFAULT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_FLOAT_DEFAULT 2
     * }
     */
    public static int LUA_FLOAT_DEFAULT() {
        return LUA_FLOAT_DEFAULT;
    }
    private static final int LUA_INT_TYPE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_INT_TYPE 3
     * }
     */
    public static int LUA_INT_TYPE() {
        return LUA_INT_TYPE;
    }
    private static final int LUA_FLOAT_TYPE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_FLOAT_TYPE 2
     * }
     */
    public static int LUA_FLOAT_TYPE() {
        return LUA_FLOAT_TYPE;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_PATH_SEP ";"
     * }
     */
    public static MemorySegment LUA_PATH_SEP() {
        class Holder {
            static final MemorySegment LUA_PATH_SEP
                = luahpp_h.LIBRARY_ARENA.allocateFrom(";");
        }
        return Holder.LUA_PATH_SEP;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_PATH_MARK "?"
     * }
     */
    public static MemorySegment LUA_PATH_MARK() {
        class Holder {
            static final MemorySegment LUA_PATH_MARK
                = luahpp_h.LIBRARY_ARENA.allocateFrom("?");
        }
        return Holder.LUA_PATH_MARK;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_EXEC_DIR "!"
     * }
     */
    public static MemorySegment LUA_EXEC_DIR() {
        class Holder {
            static final MemorySegment LUA_EXEC_DIR
                = luahpp_h.LIBRARY_ARENA.allocateFrom("!");
        }
        return Holder.LUA_EXEC_DIR;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_VDIR "5.4"
     * }
     */
    public static MemorySegment LUA_VDIR() {
        class Holder {
            static final MemorySegment LUA_VDIR
                = luahpp_h.LIBRARY_ARENA.allocateFrom("5.4");
        }
        return Holder.LUA_VDIR;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_LDIR "!\lua\"
     * }
     */
    public static MemorySegment LUA_LDIR() {
        class Holder {
            static final MemorySegment LUA_LDIR
                = luahpp_h.LIBRARY_ARENA.allocateFrom("!\\lua\\");
        }
        return Holder.LUA_LDIR;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_CDIR "!\"
     * }
     */
    public static MemorySegment LUA_CDIR() {
        class Holder {
            static final MemorySegment LUA_CDIR
                = luahpp_h.LIBRARY_ARENA.allocateFrom("!\\");
        }
        return Holder.LUA_CDIR;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_SHRDIR "!\..\share\lua\5.4\"
     * }
     */
    public static MemorySegment LUA_SHRDIR() {
        class Holder {
            static final MemorySegment LUA_SHRDIR
                = luahpp_h.LIBRARY_ARENA.allocateFrom("!\\..\\share\\lua\\5.4\\");
        }
        return Holder.LUA_SHRDIR;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_PATH_DEFAULT "!\lua\?.lua;!\lua\?\init.lua;!\?.lua;!\?\init.lua;!\..\share\lua\5.4\?.lua;!\..\share\lua\5.4\?\init.lua;.\?.lua;.\?\init.lua"
     * }
     */
    public static MemorySegment LUA_PATH_DEFAULT() {
        class Holder {
            static final MemorySegment LUA_PATH_DEFAULT
                = luahpp_h.LIBRARY_ARENA.allocateFrom("!\\lua\\?.lua;!\\lua\\?\\init.lua;!\\?.lua;!\\?\\init.lua;!\\..\\share\\lua\\5.4\\?.lua;!\\..\\share\\lua\\5.4\\?\\init.lua;.\\?.lua;.\\?\\init.lua");
        }
        return Holder.LUA_PATH_DEFAULT;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_CPATH_DEFAULT "!\?.dll;!\..\lib\lua\5.4\?.dll;!\loadall.dll;.\?.dll"
     * }
     */
    public static MemorySegment LUA_CPATH_DEFAULT() {
        class Holder {
            static final MemorySegment LUA_CPATH_DEFAULT
                = luahpp_h.LIBRARY_ARENA.allocateFrom("!\\?.dll;!\\..\\lib\\lua\\5.4\\?.dll;!\\loadall.dll;.\\?.dll");
        }
        return Holder.LUA_CPATH_DEFAULT;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_DIRSEP "\"
     * }
     */
    public static MemorySegment LUA_DIRSEP() {
        class Holder {
            static final MemorySegment LUA_DIRSEP
                = luahpp_h.LIBRARY_ARENA.allocateFrom("\\");
        }
        return Holder.LUA_DIRSEP;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_NUMBER_FRMLEN ""
     * }
     */
    public static MemorySegment LUA_NUMBER_FRMLEN() {
        class Holder {
            static final MemorySegment LUA_NUMBER_FRMLEN
                = luahpp_h.LIBRARY_ARENA.allocateFrom("");
        }
        return Holder.LUA_NUMBER_FRMLEN;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_NUMBER_FMT "%.14g"
     * }
     */
    public static MemorySegment LUA_NUMBER_FMT() {
        class Holder {
            static final MemorySegment LUA_NUMBER_FMT
                = luahpp_h.LIBRARY_ARENA.allocateFrom("%.14g");
        }
        return Holder.LUA_NUMBER_FMT;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_INTEGER_FMT "%lld"
     * }
     */
    public static MemorySegment LUA_INTEGER_FMT() {
        class Holder {
            static final MemorySegment LUA_INTEGER_FMT
                = luahpp_h.LIBRARY_ARENA.allocateFrom("%lld");
        }
        return Holder.LUA_INTEGER_FMT;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_INTEGER_FRMLEN "ll"
     * }
     */
    public static MemorySegment LUA_INTEGER_FRMLEN() {
        class Holder {
            static final MemorySegment LUA_INTEGER_FRMLEN
                = luahpp_h.LIBRARY_ARENA.allocateFrom("ll");
        }
        return Holder.LUA_INTEGER_FRMLEN;
    }
    private static final long LUA_MAXINTEGER = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LUA_MAXINTEGER 9223372036854775807
     * }
     */
    public static long LUA_MAXINTEGER() {
        return LUA_MAXINTEGER;
    }
    private static final long LUA_MININTEGER = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LUA_MININTEGER -9223372036854775808
     * }
     */
    public static long LUA_MININTEGER() {
        return LUA_MININTEGER;
    }
    private static final long LUA_MAXUNSIGNED = -1L;
    /**
     * {@snippet lang=c :
     * #define LUA_MAXUNSIGNED -1
     * }
     */
    public static long LUA_MAXUNSIGNED() {
        return LUA_MAXUNSIGNED;
    }
    private static final long LUA_EXTRASPACE = 8L;
    /**
     * {@snippet lang=c :
     * #define LUA_EXTRASPACE 8
     * }
     */
    public static long LUA_EXTRASPACE() {
        return LUA_EXTRASPACE;
    }
    private static final int LUAL_BUFFERSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define LUAL_BUFFERSIZE 1024
     * }
     */
    public static int LUAL_BUFFERSIZE() {
        return LUAL_BUFFERSIZE;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_VERSION_MAJOR "5"
     * }
     */
    public static MemorySegment LUA_VERSION_MAJOR() {
        class Holder {
            static final MemorySegment LUA_VERSION_MAJOR
                = luahpp_h.LIBRARY_ARENA.allocateFrom("5");
        }
        return Holder.LUA_VERSION_MAJOR;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_VERSION_MINOR "4"
     * }
     */
    public static MemorySegment LUA_VERSION_MINOR() {
        class Holder {
            static final MemorySegment LUA_VERSION_MINOR
                = luahpp_h.LIBRARY_ARENA.allocateFrom("4");
        }
        return Holder.LUA_VERSION_MINOR;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_VERSION_RELEASE "4"
     * }
     */
    public static MemorySegment LUA_VERSION_RELEASE() {
        class Holder {
            static final MemorySegment LUA_VERSION_RELEASE
                = luahpp_h.LIBRARY_ARENA.allocateFrom("4");
        }
        return Holder.LUA_VERSION_RELEASE;
    }
    private static final int LUA_VERSION_RELEASE_NUM = (int)50404L;
    /**
     * {@snippet lang=c :
     * #define LUA_VERSION_RELEASE_NUM 50404
     * }
     */
    public static int LUA_VERSION_RELEASE_NUM() {
        return LUA_VERSION_RELEASE_NUM;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_VERSION "Lua 5.4"
     * }
     */
    public static MemorySegment LUA_VERSION() {
        class Holder {
            static final MemorySegment LUA_VERSION
                = luahpp_h.LIBRARY_ARENA.allocateFrom("Lua 5.4");
        }
        return Holder.LUA_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_RELEASE "Lua 5.4.4"
     * }
     */
    public static MemorySegment LUA_RELEASE() {
        class Holder {
            static final MemorySegment LUA_RELEASE
                = luahpp_h.LIBRARY_ARENA.allocateFrom("Lua 5.4.4");
        }
        return Holder.LUA_RELEASE;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_COPYRIGHT "Lua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio"
     * }
     */
    public static MemorySegment LUA_COPYRIGHT() {
        class Holder {
            static final MemorySegment LUA_COPYRIGHT
                = luahpp_h.LIBRARY_ARENA.allocateFrom("Lua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio");
        }
        return Holder.LUA_COPYRIGHT;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_AUTHORS "R. Ierusalimschy, L. H. de Figueiredo, W. Celes"
     * }
     */
    public static MemorySegment LUA_AUTHORS() {
        class Holder {
            static final MemorySegment LUA_AUTHORS
                = luahpp_h.LIBRARY_ARENA.allocateFrom("R. Ierusalimschy, L. H. de Figueiredo, W. Celes");
        }
        return Holder.LUA_AUTHORS;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_SIGNATURE "Lua"
     * }
     */
    public static MemorySegment LUA_SIGNATURE() {
        class Holder {
            static final MemorySegment LUA_SIGNATURE
                = luahpp_h.LIBRARY_ARENA.allocateFrom("\u001bLua");
        }
        return Holder.LUA_SIGNATURE;
    }
    private static final int LUA_MULTRET = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define LUA_MULTRET -1
     * }
     */
    public static int LUA_MULTRET() {
        return LUA_MULTRET;
    }
    private static final int LUA_REGISTRYINDEX = (int)-1001000L;
    /**
     * {@snippet lang=c :
     * #define LUA_REGISTRYINDEX -1001000
     * }
     */
    public static int LUA_REGISTRYINDEX() {
        return LUA_REGISTRYINDEX;
    }
    private static final int LUA_TNONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define LUA_TNONE -1
     * }
     */
    public static int LUA_TNONE() {
        return LUA_TNONE;
    }
    private static final int LUA_RIDX_LAST = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_RIDX_LAST 2
     * }
     */
    public static int LUA_RIDX_LAST() {
        return LUA_RIDX_LAST;
    }
    private static final int LUA_NUMTAGS = (int)9L;
    /**
     * {@snippet lang=c :
     * #define LUA_NUMTAGS 9
     * }
     */
    public static int LUA_NUMTAGS() {
        return LUA_NUMTAGS;
    }
    private static final int LUA_MASKCALL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_MASKCALL 1
     * }
     */
    public static int LUA_MASKCALL() {
        return LUA_MASKCALL;
    }
    private static final int LUA_MASKRET = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_MASKRET 2
     * }
     */
    public static int LUA_MASKRET() {
        return LUA_MASKRET;
    }
    private static final int LUA_MASKLINE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define LUA_MASKLINE 4
     * }
     */
    public static int LUA_MASKLINE() {
        return LUA_MASKLINE;
    }
    private static final int LUA_MASKCOUNT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define LUA_MASKCOUNT 8
     * }
     */
    public static int LUA_MASKCOUNT() {
        return LUA_MASKCOUNT;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_VERSUFFIX "_5_4"
     * }
     */
    public static MemorySegment LUA_VERSUFFIX() {
        class Holder {
            static final MemorySegment LUA_VERSUFFIX
                = luahpp_h.LIBRARY_ARENA.allocateFrom("_5_4");
        }
        return Holder.LUA_VERSUFFIX;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_COLIBNAME "coroutine"
     * }
     */
    public static MemorySegment LUA_COLIBNAME() {
        class Holder {
            static final MemorySegment LUA_COLIBNAME
                = luahpp_h.LIBRARY_ARENA.allocateFrom("coroutine");
        }
        return Holder.LUA_COLIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_TABLIBNAME "table"
     * }
     */
    public static MemorySegment LUA_TABLIBNAME() {
        class Holder {
            static final MemorySegment LUA_TABLIBNAME
                = luahpp_h.LIBRARY_ARENA.allocateFrom("table");
        }
        return Holder.LUA_TABLIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_IOLIBNAME "io"
     * }
     */
    public static MemorySegment LUA_IOLIBNAME() {
        class Holder {
            static final MemorySegment LUA_IOLIBNAME
                = luahpp_h.LIBRARY_ARENA.allocateFrom("io");
        }
        return Holder.LUA_IOLIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_OSLIBNAME "os"
     * }
     */
    public static MemorySegment LUA_OSLIBNAME() {
        class Holder {
            static final MemorySegment LUA_OSLIBNAME
                = luahpp_h.LIBRARY_ARENA.allocateFrom("os");
        }
        return Holder.LUA_OSLIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_STRLIBNAME "string"
     * }
     */
    public static MemorySegment LUA_STRLIBNAME() {
        class Holder {
            static final MemorySegment LUA_STRLIBNAME
                = luahpp_h.LIBRARY_ARENA.allocateFrom("string");
        }
        return Holder.LUA_STRLIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_UTF8LIBNAME "utf8"
     * }
     */
    public static MemorySegment LUA_UTF8LIBNAME() {
        class Holder {
            static final MemorySegment LUA_UTF8LIBNAME
                = luahpp_h.LIBRARY_ARENA.allocateFrom("utf8");
        }
        return Holder.LUA_UTF8LIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_MATHLIBNAME "math"
     * }
     */
    public static MemorySegment LUA_MATHLIBNAME() {
        class Holder {
            static final MemorySegment LUA_MATHLIBNAME
                = luahpp_h.LIBRARY_ARENA.allocateFrom("math");
        }
        return Holder.LUA_MATHLIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_DBLIBNAME "debug"
     * }
     */
    public static MemorySegment LUA_DBLIBNAME() {
        class Holder {
            static final MemorySegment LUA_DBLIBNAME
                = luahpp_h.LIBRARY_ARENA.allocateFrom("debug");
        }
        return Holder.LUA_DBLIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_LOADLIBNAME "package"
     * }
     */
    public static MemorySegment LUA_LOADLIBNAME() {
        class Holder {
            static final MemorySegment LUA_LOADLIBNAME
                = luahpp_h.LIBRARY_ARENA.allocateFrom("package");
        }
        return Holder.LUA_LOADLIBNAME;
    }
    private static final int _UCRT_DISABLED_WARNINGS = (int)4324L;
    /**
     * {@snippet lang=c :
     * #define _UCRT_DISABLED_WARNINGS 4324
     * }
     */
    public static int _UCRT_DISABLED_WARNINGS() {
        return _UCRT_DISABLED_WARNINGS;
    }
    private static final long _TRUNCATE = -1L;
    /**
     * {@snippet lang=c :
     * #define _TRUNCATE -1
     * }
     */
    public static long _TRUNCATE() {
        return _TRUNCATE;
    }
    private static final long _CRT_SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SIZE_MAX -1
     * }
     */
    public static long _CRT_SIZE_MAX() {
        return _CRT_SIZE_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define __FILEW__ "C"
     * }
     */
    public static MemorySegment __FILEW__() {
        class Holder {
            static final MemorySegment __FILEW__
                = luahpp_h.LIBRARY_ARENA.allocateFrom("C");
        }
        return Holder.__FILEW__;
    }
    private static final int __STDC_SECURE_LIB__ = (int)200411L;
    /**
     * {@snippet lang=c :
     * #define __STDC_SECURE_LIB__ 200411
     * }
     */
    public static int __STDC_SECURE_LIB__() {
        return __STDC_SECURE_LIB__;
    }
    private static final int __GOT_SECURE_LIB__ = (int)200411L;
    /**
     * {@snippet lang=c :
     * #define __GOT_SECURE_LIB__ 200411
     * }
     */
    public static int __GOT_SECURE_LIB__() {
        return __GOT_SECURE_LIB__;
    }
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_STDIO_SYMBOL_PREFIX ""
     * }
     */
    public static MemorySegment _CRT_INTERNAL_STDIO_SYMBOL_PREFIX() {
        class Holder {
            static final MemorySegment _CRT_INTERNAL_STDIO_SYMBOL_PREFIX
                = luahpp_h.LIBRARY_ARENA.allocateFrom("");
        }
        return Holder._CRT_INTERNAL_STDIO_SYMBOL_PREFIX;
    }
    private static final long _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION = 1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION 1
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION() {
        return _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION;
    }
    private static final long _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR = 2L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR 2
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR() {
        return _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR;
    }
    private static final long _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS = 4L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS 4
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS() {
        return _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS;
    }
    private static final long _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY = 8L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY 8
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY() {
        return _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY;
    }
    private static final long _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS = 16L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS 16
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS() {
        return _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS;
    }
    private static final long _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING = 32L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING 32
     * }
     */
    public static long _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING() {
        return _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING;
    }
    private static final long _CRT_INTERNAL_SCANF_SECURECRT = 1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_SCANF_SECURECRT 1
     * }
     */
    public static long _CRT_INTERNAL_SCANF_SECURECRT() {
        return _CRT_INTERNAL_SCANF_SECURECRT;
    }
    private static final long _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS = 2L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS 2
     * }
     */
    public static long _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS() {
        return _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS;
    }
    private static final long _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY = 4L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY 4
     * }
     */
    public static long _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY() {
        return _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY;
    }
    private static final short WEOF = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define WEOF 65535
     * }
     */
    public static short WEOF() {
        return WEOF;
    }
    private static final int _NFILE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _NFILE 512
     * }
     */
    public static int _NFILE() {
        return _NFILE;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    private static final int L_tmpnam_s = (int)260L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam_s 260
     * }
     */
    public static int L_tmpnam_s() {
        return L_tmpnam_s;
    }
    private static final int TMP_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 2147483647
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int TMP_MAX_S = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX_S 2147483647
     * }
     */
    public static int TMP_MAX_S() {
        return TMP_MAX_S;
    }
    private static final int _TMP_MAX_S = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _TMP_MAX_S 2147483647
     * }
     */
    public static int _TMP_MAX_S() {
        return _TMP_MAX_S;
    }
    private static final int SYS_OPEN = (int)20L;
    /**
     * {@snippet lang=c :
     * #define SYS_OPEN 20
     * }
     */
    public static int SYS_OPEN() {
        return SYS_OPEN;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_GNAME "_G"
     * }
     */
    public static MemorySegment LUA_GNAME() {
        class Holder {
            static final MemorySegment LUA_GNAME
                = luahpp_h.LIBRARY_ARENA.allocateFrom("_G");
        }
        return Holder.LUA_GNAME;
    }
    private static final int LUA_ERRFILE = (int)6L;
    /**
     * {@snippet lang=c :
     * #define LUA_ERRFILE 6
     * }
     */
    public static int LUA_ERRFILE() {
        return LUA_ERRFILE;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_LOADED_TABLE "_LOADED"
     * }
     */
    public static MemorySegment LUA_LOADED_TABLE() {
        class Holder {
            static final MemorySegment LUA_LOADED_TABLE
                = luahpp_h.LIBRARY_ARENA.allocateFrom("_LOADED");
        }
        return Holder.LUA_LOADED_TABLE;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_PRELOAD_TABLE "_PRELOAD"
     * }
     */
    public static MemorySegment LUA_PRELOAD_TABLE() {
        class Holder {
            static final MemorySegment LUA_PRELOAD_TABLE
                = luahpp_h.LIBRARY_ARENA.allocateFrom("_PRELOAD");
        }
        return Holder.LUA_PRELOAD_TABLE;
    }
    private static final long LUAL_NUMSIZES = 136L;
    /**
     * {@snippet lang=c :
     * #define LUAL_NUMSIZES 136
     * }
     */
    public static long LUAL_NUMSIZES() {
        return LUAL_NUMSIZES;
    }
    private static final int LUA_NOREF = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define LUA_NOREF -2
     * }
     */
    public static int LUA_NOREF() {
        return LUA_NOREF;
    }
    private static final int LUA_REFNIL = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define LUA_REFNIL -1
     * }
     */
    public static int LUA_REFNIL() {
        return LUA_REFNIL;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_FILEHANDLE "FILE*"
     * }
     */
    public static MemorySegment LUA_FILEHANDLE() {
        class Holder {
            static final MemorySegment LUA_FILEHANDLE
                = luahpp_h.LIBRARY_ARENA.allocateFrom("FILE*");
        }
        return Holder.LUA_FILEHANDLE;
    }
}

