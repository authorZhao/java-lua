// Generated by jextract

package com.git.lua;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;
import static com.git.lua.LuaLib.SYMBOL_LOOKUP;
public class lualib_h {

    lualib_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _VCRT_COMPILER_PREPROCESSOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _VCRT_COMPILER_PREPROCESSOR 1
     * }
     */
    public static int _VCRT_COMPILER_PREPROCESSOR() {
        return _VCRT_COMPILER_PREPROCESSOR;
    }
    private static final int _SAL_VERSION = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SAL_VERSION 20
     * }
     */
    public static int _SAL_VERSION() {
        return _SAL_VERSION;
    }
    private static final int __SAL_H_VERSION = (int)180000000L;
    /**
     * {@snippet lang=c :
     * #define __SAL_H_VERSION 180000000
     * }
     */
    public static int __SAL_H_VERSION() {
        return __SAL_H_VERSION;
    }
    private static final int _USE_DECLSPECS_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_DECLSPECS_FOR_SAL 0
     * }
     */
    public static int _USE_DECLSPECS_FOR_SAL() {
        return _USE_DECLSPECS_FOR_SAL;
    }
    private static final int _USE_ATTRIBUTES_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_ATTRIBUTES_FOR_SAL 0
     * }
     */
    public static int _USE_ATTRIBUTES_FOR_SAL() {
        return _USE_ATTRIBUTES_FOR_SAL;
    }
    private static final int _CRT_PACKING = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _CRT_PACKING 8
     * }
     */
    public static int _CRT_PACKING() {
        return _CRT_PACKING;
    }
    private static final int _HAS_EXCEPTIONS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _HAS_EXCEPTIONS 1
     * }
     */
    public static int _HAS_EXCEPTIONS() {
        return _HAS_EXCEPTIONS;
    }
    private static final int _HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX17 0
     * }
     */
    public static int _HAS_CXX17() {
        return _HAS_CXX17;
    }
    private static final int _HAS_CXX20 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX20 0
     * }
     */
    public static int _HAS_CXX20() {
        return _HAS_CXX20;
    }
    private static final int _HAS_NODISCARD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_NODISCARD 0
     * }
     */
    public static int _HAS_NODISCARD() {
        return _HAS_NODISCARD;
    }
    private static final int CHAR_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CHAR_BIT 8
     * }
     */
    public static int CHAR_BIT() {
        return CHAR_BIT;
    }
    private static final int SCHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MAX 127
     * }
     */
    public static int SCHAR_MAX() {
        return SCHAR_MAX;
    }
    private static final int UCHAR_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UCHAR_MAX 255
     * }
     */
    public static int UCHAR_MAX() {
        return UCHAR_MAX;
    }
    private static final int MB_LEN_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define MB_LEN_MAX 5
     * }
     */
    public static int MB_LEN_MAX() {
        return MB_LEN_MAX;
    }
    private static final int SHRT_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MAX 32767
     * }
     */
    public static int SHRT_MAX() {
        return SHRT_MAX;
    }
    private static final int USHRT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define USHRT_MAX 65535
     * }
     */
    public static int USHRT_MAX() {
        return USHRT_MAX;
    }
    private static final int INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_MAX 2147483647
     * }
     */
    public static int INT_MAX() {
        return INT_MAX;
    }
    private static final int LUA_INT_INT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_INT_INT 1
     * }
     */
    public static int LUA_INT_INT() {
        return LUA_INT_INT;
    }
    private static final int LUA_INT_LONG = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_INT_LONG 2
     * }
     */
    public static int LUA_INT_LONG() {
        return LUA_INT_LONG;
    }
    private static final int LUA_INT_LONGLONG = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_INT_LONGLONG 3
     * }
     */
    public static int LUA_INT_LONGLONG() {
        return LUA_INT_LONGLONG;
    }
    private static final int LUA_FLOAT_FLOAT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_FLOAT_FLOAT 1
     * }
     */
    public static int LUA_FLOAT_FLOAT() {
        return LUA_FLOAT_FLOAT;
    }
    private static final int LUA_FLOAT_DOUBLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_FLOAT_DOUBLE 2
     * }
     */
    public static int LUA_FLOAT_DOUBLE() {
        return LUA_FLOAT_DOUBLE;
    }
    private static final int LUA_FLOAT_LONGDOUBLE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_FLOAT_LONGDOUBLE 3
     * }
     */
    public static int LUA_FLOAT_LONGDOUBLE() {
        return LUA_FLOAT_LONGDOUBLE;
    }
    private static final int LUA_32BITS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_32BITS 0
     * }
     */
    public static int LUA_32BITS() {
        return LUA_32BITS;
    }
    private static final int LUA_C89_NUMBERS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_C89_NUMBERS 0
     * }
     */
    public static int LUA_C89_NUMBERS() {
        return LUA_C89_NUMBERS;
    }
    private static final int LUAI_MAXSTACK = (int)1000000L;
    /**
     * {@snippet lang=c :
     * #define LUAI_MAXSTACK 1000000
     * }
     */
    public static int LUAI_MAXSTACK() {
        return LUAI_MAXSTACK;
    }
    private static final int LUA_IDSIZE = (int)60L;
    /**
     * {@snippet lang=c :
     * #define LUA_IDSIZE 60
     * }
     */
    public static int LUA_IDSIZE() {
        return LUA_IDSIZE;
    }
    private static final int LUA_VERSION_NUM = (int)504L;
    /**
     * {@snippet lang=c :
     * #define LUA_VERSION_NUM 504
     * }
     */
    public static int LUA_VERSION_NUM() {
        return LUA_VERSION_NUM;
    }
    private static final int LUA_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_OK 0
     * }
     */
    public static int LUA_OK() {
        return LUA_OK;
    }
    private static final int LUA_YIELD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_YIELD 1
     * }
     */
    public static int LUA_YIELD() {
        return LUA_YIELD;
    }
    private static final int LUA_ERRRUN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_ERRRUN 2
     * }
     */
    public static int LUA_ERRRUN() {
        return LUA_ERRRUN;
    }
    private static final int LUA_ERRSYNTAX = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_ERRSYNTAX 3
     * }
     */
    public static int LUA_ERRSYNTAX() {
        return LUA_ERRSYNTAX;
    }
    private static final int LUA_ERRMEM = (int)4L;
    /**
     * {@snippet lang=c :
     * #define LUA_ERRMEM 4
     * }
     */
    public static int LUA_ERRMEM() {
        return LUA_ERRMEM;
    }
    private static final int LUA_ERRERR = (int)5L;
    /**
     * {@snippet lang=c :
     * #define LUA_ERRERR 5
     * }
     */
    public static int LUA_ERRERR() {
        return LUA_ERRERR;
    }
    private static final int LUA_TNIL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_TNIL 0
     * }
     */
    public static int LUA_TNIL() {
        return LUA_TNIL;
    }
    private static final int LUA_TBOOLEAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_TBOOLEAN 1
     * }
     */
    public static int LUA_TBOOLEAN() {
        return LUA_TBOOLEAN;
    }
    private static final int LUA_TLIGHTUSERDATA = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_TLIGHTUSERDATA 2
     * }
     */
    public static int LUA_TLIGHTUSERDATA() {
        return LUA_TLIGHTUSERDATA;
    }
    private static final int LUA_TNUMBER = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_TNUMBER 3
     * }
     */
    public static int LUA_TNUMBER() {
        return LUA_TNUMBER;
    }
    private static final int LUA_TSTRING = (int)4L;
    /**
     * {@snippet lang=c :
     * #define LUA_TSTRING 4
     * }
     */
    public static int LUA_TSTRING() {
        return LUA_TSTRING;
    }
    private static final int LUA_TTABLE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define LUA_TTABLE 5
     * }
     */
    public static int LUA_TTABLE() {
        return LUA_TTABLE;
    }
    private static final int LUA_TFUNCTION = (int)6L;
    /**
     * {@snippet lang=c :
     * #define LUA_TFUNCTION 6
     * }
     */
    public static int LUA_TFUNCTION() {
        return LUA_TFUNCTION;
    }
    private static final int LUA_TUSERDATA = (int)7L;
    /**
     * {@snippet lang=c :
     * #define LUA_TUSERDATA 7
     * }
     */
    public static int LUA_TUSERDATA() {
        return LUA_TUSERDATA;
    }
    private static final int LUA_TTHREAD = (int)8L;
    /**
     * {@snippet lang=c :
     * #define LUA_TTHREAD 8
     * }
     */
    public static int LUA_TTHREAD() {
        return LUA_TTHREAD;
    }
    private static final int LUA_NUMTYPES = (int)9L;
    /**
     * {@snippet lang=c :
     * #define LUA_NUMTYPES 9
     * }
     */
    public static int LUA_NUMTYPES() {
        return LUA_NUMTYPES;
    }
    private static final int LUA_MINSTACK = (int)20L;
    /**
     * {@snippet lang=c :
     * #define LUA_MINSTACK 20
     * }
     */
    public static int LUA_MINSTACK() {
        return LUA_MINSTACK;
    }
    private static final int LUA_RIDX_MAINTHREAD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_RIDX_MAINTHREAD 1
     * }
     */
    public static int LUA_RIDX_MAINTHREAD() {
        return LUA_RIDX_MAINTHREAD;
    }
    private static final int LUA_RIDX_GLOBALS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_RIDX_GLOBALS 2
     * }
     */
    public static int LUA_RIDX_GLOBALS() {
        return LUA_RIDX_GLOBALS;
    }
    private static final int LUA_OPADD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPADD 0
     * }
     */
    public static int LUA_OPADD() {
        return LUA_OPADD;
    }
    private static final int LUA_OPSUB = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPSUB 1
     * }
     */
    public static int LUA_OPSUB() {
        return LUA_OPSUB;
    }
    private static final int LUA_OPMUL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPMUL 2
     * }
     */
    public static int LUA_OPMUL() {
        return LUA_OPMUL;
    }
    private static final int LUA_OPMOD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPMOD 3
     * }
     */
    public static int LUA_OPMOD() {
        return LUA_OPMOD;
    }
    private static final int LUA_OPPOW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPPOW 4
     * }
     */
    public static int LUA_OPPOW() {
        return LUA_OPPOW;
    }
    private static final int LUA_OPDIV = (int)5L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPDIV 5
     * }
     */
    public static int LUA_OPDIV() {
        return LUA_OPDIV;
    }
    private static final int LUA_OPIDIV = (int)6L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPIDIV 6
     * }
     */
    public static int LUA_OPIDIV() {
        return LUA_OPIDIV;
    }
    private static final int LUA_OPBAND = (int)7L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPBAND 7
     * }
     */
    public static int LUA_OPBAND() {
        return LUA_OPBAND;
    }
    private static final int LUA_OPBOR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPBOR 8
     * }
     */
    public static int LUA_OPBOR() {
        return LUA_OPBOR;
    }
    private static final int LUA_OPBXOR = (int)9L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPBXOR 9
     * }
     */
    public static int LUA_OPBXOR() {
        return LUA_OPBXOR;
    }
    private static final int LUA_OPSHL = (int)10L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPSHL 10
     * }
     */
    public static int LUA_OPSHL() {
        return LUA_OPSHL;
    }
    private static final int LUA_OPSHR = (int)11L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPSHR 11
     * }
     */
    public static int LUA_OPSHR() {
        return LUA_OPSHR;
    }
    private static final int LUA_OPUNM = (int)12L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPUNM 12
     * }
     */
    public static int LUA_OPUNM() {
        return LUA_OPUNM;
    }
    private static final int LUA_OPBNOT = (int)13L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPBNOT 13
     * }
     */
    public static int LUA_OPBNOT() {
        return LUA_OPBNOT;
    }
    private static final int LUA_OPEQ = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPEQ 0
     * }
     */
    public static int LUA_OPEQ() {
        return LUA_OPEQ;
    }
    private static final int LUA_OPLT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPLT 1
     * }
     */
    public static int LUA_OPLT() {
        return LUA_OPLT;
    }
    private static final int LUA_OPLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_OPLE 2
     * }
     */
    public static int LUA_OPLE() {
        return LUA_OPLE;
    }
    private static final int LUA_GCSTOP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCSTOP 0
     * }
     */
    public static int LUA_GCSTOP() {
        return LUA_GCSTOP;
    }
    private static final int LUA_GCRESTART = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCRESTART 1
     * }
     */
    public static int LUA_GCRESTART() {
        return LUA_GCRESTART;
    }
    private static final int LUA_GCCOLLECT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCCOLLECT 2
     * }
     */
    public static int LUA_GCCOLLECT() {
        return LUA_GCCOLLECT;
    }
    private static final int LUA_GCCOUNT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCCOUNT 3
     * }
     */
    public static int LUA_GCCOUNT() {
        return LUA_GCCOUNT;
    }
    private static final int LUA_GCCOUNTB = (int)4L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCCOUNTB 4
     * }
     */
    public static int LUA_GCCOUNTB() {
        return LUA_GCCOUNTB;
    }
    private static final int LUA_GCSTEP = (int)5L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCSTEP 5
     * }
     */
    public static int LUA_GCSTEP() {
        return LUA_GCSTEP;
    }
    private static final int LUA_GCSETPAUSE = (int)6L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCSETPAUSE 6
     * }
     */
    public static int LUA_GCSETPAUSE() {
        return LUA_GCSETPAUSE;
    }
    private static final int LUA_GCSETSTEPMUL = (int)7L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCSETSTEPMUL 7
     * }
     */
    public static int LUA_GCSETSTEPMUL() {
        return LUA_GCSETSTEPMUL;
    }
    private static final int LUA_GCISRUNNING = (int)9L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCISRUNNING 9
     * }
     */
    public static int LUA_GCISRUNNING() {
        return LUA_GCISRUNNING;
    }
    private static final int LUA_GCGEN = (int)10L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCGEN 10
     * }
     */
    public static int LUA_GCGEN() {
        return LUA_GCGEN;
    }
    private static final int LUA_GCINC = (int)11L;
    /**
     * {@snippet lang=c :
     * #define LUA_GCINC 11
     * }
     */
    public static int LUA_GCINC() {
        return LUA_GCINC;
    }
    private static final int LUA_HOOKCALL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define LUA_HOOKCALL 0
     * }
     */
    public static int LUA_HOOKCALL() {
        return LUA_HOOKCALL;
    }
    private static final int LUA_HOOKRET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_HOOKRET 1
     * }
     */
    public static int LUA_HOOKRET() {
        return LUA_HOOKRET;
    }
    private static final int LUA_HOOKLINE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_HOOKLINE 2
     * }
     */
    public static int LUA_HOOKLINE() {
        return LUA_HOOKLINE;
    }
    private static final int LUA_HOOKCOUNT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_HOOKCOUNT 3
     * }
     */
    public static int LUA_HOOKCOUNT() {
        return LUA_HOOKCOUNT;
    }
    private static final int LUA_HOOKTAILCALL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define LUA_HOOKTAILCALL 4
     * }
     */
    public static int LUA_HOOKTAILCALL() {
        return LUA_HOOKTAILCALL;
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list va_list
     * }
     */
    public static final AddressLayout va_list = lualib_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = lualib_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = lualib_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long size_t
     * }
     */
    public static final OfLong size_t = lualib_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wchar_t
     * }
     */
    public static final OfShort wchar_t = lualib_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef double max_align_t
     * }
     */
    public static final OfDouble max_align_t = lualib_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = lualib_h.C_LONG_LONG;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __va_start(va_list *, ...)
     * }
     */
    public static class __va_start {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                lualib_h.C_POINTER
            );
        private static final MemorySegment ADDR = lualib_h.findOrThrow("__va_start");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __va_start(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __va_start(va_list *, ...)
         * }
         */
        public static __va_start makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __va_start(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__va_start", x0, x1);
                }
                spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long long intptr_t
     * }
     */
    public static final OfLong intptr_t = lualib_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef _Bool __vcrt_bool
     * }
     */
    public static final OfBoolean __vcrt_bool = lualib_h.C_BOOL;

    private static class __security_init_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("__security_init_cookie"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static FunctionDescriptor __security_init_cookie$descriptor() {
        return __security_init_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MethodHandle __security_init_cookie$handle() {
        return __security_init_cookie.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static void __security_init_cookie() {
        var mh$ = __security_init_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_init_cookie");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_check_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("__security_check_cookie"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __security_check_cookie$descriptor() {
        return __security_check_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __security_check_cookie$handle() {
        return __security_check_cookie.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static void __security_check_cookie(long _StackCookie) {
        var mh$ = __security_check_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_check_cookie", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __report_gsfailure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("__report_gsfailure"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __report_gsfailure$descriptor() {
        return __report_gsfailure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __report_gsfailure$handle() {
        return __report_gsfailure.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static void __report_gsfailure(long _StackCookie) {
        var mh$ = __report_gsfailure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__report_gsfailure", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_cookie$constants {
        public static final OfLong LAYOUT = lualib_h.C_LONG_LONG;
        public static final MemorySegment SEGMENT = lualib_h.findOrThrow("__security_cookie").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static OfLong __security_cookie$layout() {
        return __security_cookie$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static MemorySegment __security_cookie$segment() {
        return __security_cookie$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static long __security_cookie() {
        return __security_cookie$constants.SEGMENT.get(__security_cookie$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static void __security_cookie(long varValue) {
        __security_cookie$constants.SEGMENT.set(__security_cookie$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef double lua_Number
     * }
     */
    public static final OfDouble lua_Number = lualib_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef long long lua_Integer
     * }
     */
    public static final OfLong lua_Integer = lualib_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long lua_Unsigned
     * }
     */
    public static final OfLong lua_Unsigned = lualib_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ptrdiff_t lua_KContext
     * }
     */
    public static final OfLong lua_KContext = lualib_h.C_LONG_LONG;

    private static class lua_ident$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, lualib_h.C_CHAR);
        public static final MemorySegment SEGMENT = lualib_h.findOrThrow("lua_ident").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char lua_ident[]
     * }
     */
    public static SequenceLayout lua_ident$layout() {
        return lua_ident$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char lua_ident[]
     * }
     */
    public static long[] lua_ident$dimensions() {
        return lua_ident$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char lua_ident[]
     * }
     */
    public static MemorySegment lua_ident() {
        return lua_ident$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char lua_ident[]
     * }
     */
    public static void lua_ident(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, lua_ident$constants.SEGMENT, 0L, lua_ident$constants.LAYOUT.byteSize());
    }

    private static class lua_newstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_newstate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_State *(lua_newstate)(lua_Alloc f, void *ud)
     * }
     */
    public static FunctionDescriptor lua_newstate$descriptor() {
        return lua_newstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_State *(lua_newstate)(lua_Alloc f, void *ud)
     * }
     */
    public static MethodHandle lua_newstate$handle() {
        return lua_newstate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_State *(lua_newstate)(lua_Alloc f, void *ud)
     * }
     */
    public static MemorySegment lua_newstate(MemorySegment f, MemorySegment ud) {
        var mh$ = lua_newstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_newstate", f, ud);
            }
            return (MemorySegment)mh$.invokeExact(f, ud);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_close"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_close)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_close$descriptor() {
        return lua_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_close)(lua_State *L)
     * }
     */
    public static MethodHandle lua_close$handle() {
        return lua_close.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_close)(lua_State *L)
     * }
     */
    public static void lua_close(MemorySegment L) {
        var mh$ = lua_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_close", L);
            }
            mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_newthread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_newthread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_State *(lua_newthread)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_newthread$descriptor() {
        return lua_newthread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_State *(lua_newthread)(lua_State *L)
     * }
     */
    public static MethodHandle lua_newthread$handle() {
        return lua_newthread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_State *(lua_newthread)(lua_State *L)
     * }
     */
    public static MemorySegment lua_newthread(MemorySegment L) {
        var mh$ = lua_newthread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_newthread", L);
            }
            return (MemorySegment)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_resetthread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_resetthread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_resetthread)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_resetthread$descriptor() {
        return lua_resetthread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_resetthread)(lua_State *L)
     * }
     */
    public static MethodHandle lua_resetthread$handle() {
        return lua_resetthread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_resetthread)(lua_State *L)
     * }
     */
    public static int lua_resetthread(MemorySegment L) {
        var mh$ = lua_resetthread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_resetthread", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_atpanic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_atpanic"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_CFunction (lua_atpanic)(lua_State *L, lua_CFunction panicf)
     * }
     */
    public static FunctionDescriptor lua_atpanic$descriptor() {
        return lua_atpanic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_CFunction (lua_atpanic)(lua_State *L, lua_CFunction panicf)
     * }
     */
    public static MethodHandle lua_atpanic$handle() {
        return lua_atpanic.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_CFunction (lua_atpanic)(lua_State *L, lua_CFunction panicf)
     * }
     */
    public static MemorySegment lua_atpanic(MemorySegment L, MemorySegment panicf) {
        var mh$ = lua_atpanic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_atpanic", L, panicf);
            }
            return (MemorySegment)mh$.invokeExact(L, panicf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_DOUBLE,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_version"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Number (lua_version)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_version$descriptor() {
        return lua_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Number (lua_version)(lua_State *L)
     * }
     */
    public static MethodHandle lua_version$handle() {
        return lua_version.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Number (lua_version)(lua_State *L)
     * }
     */
    public static double lua_version(MemorySegment L) {
        var mh$ = lua_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_version", L);
            }
            return (double)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_absindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_absindex"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_absindex)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_absindex$descriptor() {
        return lua_absindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_absindex)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_absindex$handle() {
        return lua_absindex.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_absindex)(lua_State *L, int idx)
     * }
     */
    public static int lua_absindex(MemorySegment L, int idx) {
        var mh$ = lua_absindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_absindex", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_gettop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_gettop"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_gettop)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_gettop$descriptor() {
        return lua_gettop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_gettop)(lua_State *L)
     * }
     */
    public static MethodHandle lua_gettop$handle() {
        return lua_gettop.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_gettop)(lua_State *L)
     * }
     */
    public static int lua_gettop(MemorySegment L) {
        var mh$ = lua_gettop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_gettop", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_settop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_settop"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_settop)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_settop$descriptor() {
        return lua_settop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_settop)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_settop$handle() {
        return lua_settop.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_settop)(lua_State *L, int idx)
     * }
     */
    public static void lua_settop(MemorySegment L, int idx) {
        var mh$ = lua_settop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_settop", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushvalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_pushvalue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_pushvalue)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_pushvalue$descriptor() {
        return lua_pushvalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_pushvalue)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_pushvalue$handle() {
        return lua_pushvalue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_pushvalue)(lua_State *L, int idx)
     * }
     */
    public static void lua_pushvalue(MemorySegment L, int idx) {
        var mh$ = lua_pushvalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushvalue", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rotate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_rotate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_rotate)(lua_State *L, int idx, int n)
     * }
     */
    public static FunctionDescriptor lua_rotate$descriptor() {
        return lua_rotate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_rotate)(lua_State *L, int idx, int n)
     * }
     */
    public static MethodHandle lua_rotate$handle() {
        return lua_rotate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_rotate)(lua_State *L, int idx, int n)
     * }
     */
    public static void lua_rotate(MemorySegment L, int idx, int n) {
        var mh$ = lua_rotate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rotate", L, idx, n);
            }
            mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_copy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_copy)(lua_State *L, int fromidx, int toidx)
     * }
     */
    public static FunctionDescriptor lua_copy$descriptor() {
        return lua_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_copy)(lua_State *L, int fromidx, int toidx)
     * }
     */
    public static MethodHandle lua_copy$handle() {
        return lua_copy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_copy)(lua_State *L, int fromidx, int toidx)
     * }
     */
    public static void lua_copy(MemorySegment L, int fromidx, int toidx) {
        var mh$ = lua_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_copy", L, fromidx, toidx);
            }
            mh$.invokeExact(L, fromidx, toidx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_checkstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_checkstack"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_checkstack)(lua_State *L, int n)
     * }
     */
    public static FunctionDescriptor lua_checkstack$descriptor() {
        return lua_checkstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_checkstack)(lua_State *L, int n)
     * }
     */
    public static MethodHandle lua_checkstack$handle() {
        return lua_checkstack.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_checkstack)(lua_State *L, int n)
     * }
     */
    public static int lua_checkstack(MemorySegment L, int n) {
        var mh$ = lua_checkstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_checkstack", L, n);
            }
            return (int)mh$.invokeExact(L, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_xmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_xmove"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_xmove)(lua_State *from, lua_State *to, int n)
     * }
     */
    public static FunctionDescriptor lua_xmove$descriptor() {
        return lua_xmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_xmove)(lua_State *from, lua_State *to, int n)
     * }
     */
    public static MethodHandle lua_xmove$handle() {
        return lua_xmove.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_xmove)(lua_State *from, lua_State *to, int n)
     * }
     */
    public static void lua_xmove(MemorySegment from, MemorySegment to, int n) {
        var mh$ = lua_xmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_xmove", from, to, n);
            }
            mh$.invokeExact(from, to, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_isnumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_isnumber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_isnumber)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_isnumber$descriptor() {
        return lua_isnumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_isnumber)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_isnumber$handle() {
        return lua_isnumber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_isnumber)(lua_State *L, int idx)
     * }
     */
    public static int lua_isnumber(MemorySegment L, int idx) {
        var mh$ = lua_isnumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_isnumber", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_isstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_isstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_isstring)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_isstring$descriptor() {
        return lua_isstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_isstring)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_isstring$handle() {
        return lua_isstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_isstring)(lua_State *L, int idx)
     * }
     */
    public static int lua_isstring(MemorySegment L, int idx) {
        var mh$ = lua_isstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_isstring", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_iscfunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_iscfunction"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_iscfunction)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_iscfunction$descriptor() {
        return lua_iscfunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_iscfunction)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_iscfunction$handle() {
        return lua_iscfunction.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_iscfunction)(lua_State *L, int idx)
     * }
     */
    public static int lua_iscfunction(MemorySegment L, int idx) {
        var mh$ = lua_iscfunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_iscfunction", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_isinteger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_isinteger"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_isinteger)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_isinteger$descriptor() {
        return lua_isinteger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_isinteger)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_isinteger$handle() {
        return lua_isinteger.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_isinteger)(lua_State *L, int idx)
     * }
     */
    public static int lua_isinteger(MemorySegment L, int idx) {
        var mh$ = lua_isinteger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_isinteger", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_isuserdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_isuserdata"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_isuserdata)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_isuserdata$descriptor() {
        return lua_isuserdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_isuserdata)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_isuserdata$handle() {
        return lua_isuserdata.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_isuserdata)(lua_State *L, int idx)
     * }
     */
    public static int lua_isuserdata(MemorySegment L, int idx) {
        var mh$ = lua_isuserdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_isuserdata", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_type"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_type)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_type$descriptor() {
        return lua_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_type)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_type$handle() {
        return lua_type.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_type)(lua_State *L, int idx)
     * }
     */
    public static int lua_type(MemorySegment L, int idx) {
        var mh$ = lua_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_type", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_typename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_typename"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_typename)(lua_State *L, int tp)
     * }
     */
    public static FunctionDescriptor lua_typename$descriptor() {
        return lua_typename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_typename)(lua_State *L, int tp)
     * }
     */
    public static MethodHandle lua_typename$handle() {
        return lua_typename.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_typename)(lua_State *L, int tp)
     * }
     */
    public static MemorySegment lua_typename(MemorySegment L, int tp) {
        var mh$ = lua_typename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_typename", L, tp);
            }
            return (MemorySegment)mh$.invokeExact(L, tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_tonumberx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_DOUBLE,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_tonumberx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Number (lua_tonumberx)(lua_State *L, int idx, int *isnum)
     * }
     */
    public static FunctionDescriptor lua_tonumberx$descriptor() {
        return lua_tonumberx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Number (lua_tonumberx)(lua_State *L, int idx, int *isnum)
     * }
     */
    public static MethodHandle lua_tonumberx$handle() {
        return lua_tonumberx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Number (lua_tonumberx)(lua_State *L, int idx, int *isnum)
     * }
     */
    public static double lua_tonumberx(MemorySegment L, int idx, MemorySegment isnum) {
        var mh$ = lua_tonumberx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_tonumberx", L, idx, isnum);
            }
            return (double)mh$.invokeExact(L, idx, isnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_tointegerx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_LONG_LONG,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_tointegerx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Integer (lua_tointegerx)(lua_State *L, int idx, int *isnum)
     * }
     */
    public static FunctionDescriptor lua_tointegerx$descriptor() {
        return lua_tointegerx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Integer (lua_tointegerx)(lua_State *L, int idx, int *isnum)
     * }
     */
    public static MethodHandle lua_tointegerx$handle() {
        return lua_tointegerx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Integer (lua_tointegerx)(lua_State *L, int idx, int *isnum)
     * }
     */
    public static long lua_tointegerx(MemorySegment L, int idx, MemorySegment isnum) {
        var mh$ = lua_tointegerx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_tointegerx", L, idx, isnum);
            }
            return (long)mh$.invokeExact(L, idx, isnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_toboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_toboolean"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_toboolean)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_toboolean$descriptor() {
        return lua_toboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_toboolean)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_toboolean$handle() {
        return lua_toboolean.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_toboolean)(lua_State *L, int idx)
     * }
     */
    public static int lua_toboolean(MemorySegment L, int idx) {
        var mh$ = lua_toboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_toboolean", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_tolstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_tolstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_tolstring)(lua_State *L, int idx, size_t *len)
     * }
     */
    public static FunctionDescriptor lua_tolstring$descriptor() {
        return lua_tolstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_tolstring)(lua_State *L, int idx, size_t *len)
     * }
     */
    public static MethodHandle lua_tolstring$handle() {
        return lua_tolstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_tolstring)(lua_State *L, int idx, size_t *len)
     * }
     */
    public static MemorySegment lua_tolstring(MemorySegment L, int idx, MemorySegment len) {
        var mh$ = lua_tolstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_tolstring", L, idx, len);
            }
            return (MemorySegment)mh$.invokeExact(L, idx, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_LONG_LONG,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_rawlen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Unsigned (lua_rawlen)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_rawlen$descriptor() {
        return lua_rawlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Unsigned (lua_rawlen)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_rawlen$handle() {
        return lua_rawlen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Unsigned (lua_rawlen)(lua_State *L, int idx)
     * }
     */
    public static long lua_rawlen(MemorySegment L, int idx) {
        var mh$ = lua_rawlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawlen", L, idx);
            }
            return (long)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_tocfunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_tocfunction"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_CFunction (lua_tocfunction)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_tocfunction$descriptor() {
        return lua_tocfunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_CFunction (lua_tocfunction)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_tocfunction$handle() {
        return lua_tocfunction.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_CFunction (lua_tocfunction)(lua_State *L, int idx)
     * }
     */
    public static MemorySegment lua_tocfunction(MemorySegment L, int idx) {
        var mh$ = lua_tocfunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_tocfunction", L, idx);
            }
            return (MemorySegment)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_touserdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_touserdata"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *(lua_touserdata)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_touserdata$descriptor() {
        return lua_touserdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *(lua_touserdata)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_touserdata$handle() {
        return lua_touserdata.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *(lua_touserdata)(lua_State *L, int idx)
     * }
     */
    public static MemorySegment lua_touserdata(MemorySegment L, int idx) {
        var mh$ = lua_touserdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_touserdata", L, idx);
            }
            return (MemorySegment)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_tothread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_tothread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_State *(lua_tothread)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_tothread$descriptor() {
        return lua_tothread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_State *(lua_tothread)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_tothread$handle() {
        return lua_tothread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_State *(lua_tothread)(lua_State *L, int idx)
     * }
     */
    public static MemorySegment lua_tothread(MemorySegment L, int idx) {
        var mh$ = lua_tothread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_tothread", L, idx);
            }
            return (MemorySegment)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_topointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_topointer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const void *(lua_topointer)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_topointer$descriptor() {
        return lua_topointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const void *(lua_topointer)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_topointer$handle() {
        return lua_topointer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const void *(lua_topointer)(lua_State *L, int idx)
     * }
     */
    public static MemorySegment lua_topointer(MemorySegment L, int idx) {
        var mh$ = lua_topointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_topointer", L, idx);
            }
            return (MemorySegment)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_arith {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_arith"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_arith)(lua_State *L, int op)
     * }
     */
    public static FunctionDescriptor lua_arith$descriptor() {
        return lua_arith.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_arith)(lua_State *L, int op)
     * }
     */
    public static MethodHandle lua_arith$handle() {
        return lua_arith.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_arith)(lua_State *L, int op)
     * }
     */
    public static void lua_arith(MemorySegment L, int op) {
        var mh$ = lua_arith.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_arith", L, op);
            }
            mh$.invokeExact(L, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawequal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_rawequal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_rawequal)(lua_State *L, int idx1, int idx2)
     * }
     */
    public static FunctionDescriptor lua_rawequal$descriptor() {
        return lua_rawequal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_rawequal)(lua_State *L, int idx1, int idx2)
     * }
     */
    public static MethodHandle lua_rawequal$handle() {
        return lua_rawequal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_rawequal)(lua_State *L, int idx1, int idx2)
     * }
     */
    public static int lua_rawequal(MemorySegment L, int idx1, int idx2) {
        var mh$ = lua_rawequal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawequal", L, idx1, idx2);
            }
            return (int)mh$.invokeExact(L, idx1, idx2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_INT,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_compare"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_compare)(lua_State *L, int idx1, int idx2, int op)
     * }
     */
    public static FunctionDescriptor lua_compare$descriptor() {
        return lua_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_compare)(lua_State *L, int idx1, int idx2, int op)
     * }
     */
    public static MethodHandle lua_compare$handle() {
        return lua_compare.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_compare)(lua_State *L, int idx1, int idx2, int op)
     * }
     */
    public static int lua_compare(MemorySegment L, int idx1, int idx2, int op) {
        var mh$ = lua_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_compare", L, idx1, idx2, op);
            }
            return (int)mh$.invokeExact(L, idx1, idx2, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushnil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_pushnil"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_pushnil)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_pushnil$descriptor() {
        return lua_pushnil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_pushnil)(lua_State *L)
     * }
     */
    public static MethodHandle lua_pushnil$handle() {
        return lua_pushnil.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_pushnil)(lua_State *L)
     * }
     */
    public static void lua_pushnil(MemorySegment L) {
        var mh$ = lua_pushnil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushnil", L);
            }
            mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushnumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_DOUBLE
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_pushnumber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_pushnumber)(lua_State *L, lua_Number n)
     * }
     */
    public static FunctionDescriptor lua_pushnumber$descriptor() {
        return lua_pushnumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_pushnumber)(lua_State *L, lua_Number n)
     * }
     */
    public static MethodHandle lua_pushnumber$handle() {
        return lua_pushnumber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_pushnumber)(lua_State *L, lua_Number n)
     * }
     */
    public static void lua_pushnumber(MemorySegment L, double n) {
        var mh$ = lua_pushnumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushnumber", L, n);
            }
            mh$.invokeExact(L, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushinteger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_pushinteger"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_pushinteger)(lua_State *L, lua_Integer n)
     * }
     */
    public static FunctionDescriptor lua_pushinteger$descriptor() {
        return lua_pushinteger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_pushinteger)(lua_State *L, lua_Integer n)
     * }
     */
    public static MethodHandle lua_pushinteger$handle() {
        return lua_pushinteger.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_pushinteger)(lua_State *L, lua_Integer n)
     * }
     */
    public static void lua_pushinteger(MemorySegment L, long n) {
        var mh$ = lua_pushinteger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushinteger", L, n);
            }
            mh$.invokeExact(L, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushlstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_pushlstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_pushlstring)(lua_State *L, const char *s, size_t len)
     * }
     */
    public static FunctionDescriptor lua_pushlstring$descriptor() {
        return lua_pushlstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_pushlstring)(lua_State *L, const char *s, size_t len)
     * }
     */
    public static MethodHandle lua_pushlstring$handle() {
        return lua_pushlstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_pushlstring)(lua_State *L, const char *s, size_t len)
     * }
     */
    public static MemorySegment lua_pushlstring(MemorySegment L, MemorySegment s, long len) {
        var mh$ = lua_pushlstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushlstring", L, s, len);
            }
            return (MemorySegment)mh$.invokeExact(L, s, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_pushstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_pushstring)(lua_State *L, const char *s)
     * }
     */
    public static FunctionDescriptor lua_pushstring$descriptor() {
        return lua_pushstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_pushstring)(lua_State *L, const char *s)
     * }
     */
    public static MethodHandle lua_pushstring$handle() {
        return lua_pushstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_pushstring)(lua_State *L, const char *s)
     * }
     */
    public static MemorySegment lua_pushstring(MemorySegment L, MemorySegment s) {
        var mh$ = lua_pushstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushstring", L, s);
            }
            return (MemorySegment)mh$.invokeExact(L, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushvfstring {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_pushvfstring"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_pushvfstring)(lua_State *L, const char *fmt, va_list argp)
     * }
     */
    public static FunctionDescriptor lua_pushvfstring$descriptor() {
        return lua_pushvfstring.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_pushvfstring)(lua_State *L, const char *fmt, va_list argp)
     * }
     */
    public static MethodHandle lua_pushvfstring$handle() {
        return lua_pushvfstring.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_pushvfstring)(lua_State *L, const char *fmt, va_list argp)
     * }
     */
    public static MemorySegment lua_pushvfstring(MemorySegment L, MemorySegment fmt, MemorySegment argp) {
        var mh$ = lua_pushvfstring.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushvfstring", L, fmt, argp);
            }
            return (MemorySegment)mh$.invokeExact(L, fmt, argp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern const char *(lua_pushfstring)(lua_State *L, const char *fmt, ...)
     * }
     */
    public static class lua_pushfstring {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                lualib_h.C_POINTER,
                lualib_h.C_POINTER,
                lualib_h.C_POINTER
            );
        private static final MemorySegment ADDR = lualib_h.findOrThrow("lua_pushfstring");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private lua_pushfstring(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern const char *(lua_pushfstring)(lua_State *L, const char *fmt, ...)
         * }
         */
        public static lua_pushfstring makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new lua_pushfstring(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment L, MemorySegment fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("lua_pushfstring", L, fmt, x2);
                }
                return (MemorySegment)spreader.invokeExact(L, fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class lua_pushcclosure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_pushcclosure"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_pushcclosure)(lua_State *L, lua_CFunction fn, int n)
     * }
     */
    public static FunctionDescriptor lua_pushcclosure$descriptor() {
        return lua_pushcclosure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_pushcclosure)(lua_State *L, lua_CFunction fn, int n)
     * }
     */
    public static MethodHandle lua_pushcclosure$handle() {
        return lua_pushcclosure.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_pushcclosure)(lua_State *L, lua_CFunction fn, int n)
     * }
     */
    public static void lua_pushcclosure(MemorySegment L, MemorySegment fn, int n) {
        var mh$ = lua_pushcclosure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushcclosure", L, fn, n);
            }
            mh$.invokeExact(L, fn, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_pushboolean"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_pushboolean)(lua_State *L, int b)
     * }
     */
    public static FunctionDescriptor lua_pushboolean$descriptor() {
        return lua_pushboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_pushboolean)(lua_State *L, int b)
     * }
     */
    public static MethodHandle lua_pushboolean$handle() {
        return lua_pushboolean.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_pushboolean)(lua_State *L, int b)
     * }
     */
    public static void lua_pushboolean(MemorySegment L, int b) {
        var mh$ = lua_pushboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushboolean", L, b);
            }
            mh$.invokeExact(L, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushlightuserdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_pushlightuserdata"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_pushlightuserdata)(lua_State *L, void *p)
     * }
     */
    public static FunctionDescriptor lua_pushlightuserdata$descriptor() {
        return lua_pushlightuserdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_pushlightuserdata)(lua_State *L, void *p)
     * }
     */
    public static MethodHandle lua_pushlightuserdata$handle() {
        return lua_pushlightuserdata.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_pushlightuserdata)(lua_State *L, void *p)
     * }
     */
    public static void lua_pushlightuserdata(MemorySegment L, MemorySegment p) {
        var mh$ = lua_pushlightuserdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushlightuserdata", L, p);
            }
            mh$.invokeExact(L, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pushthread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_pushthread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_pushthread)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_pushthread$descriptor() {
        return lua_pushthread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_pushthread)(lua_State *L)
     * }
     */
    public static MethodHandle lua_pushthread$handle() {
        return lua_pushthread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_pushthread)(lua_State *L)
     * }
     */
    public static int lua_pushthread(MemorySegment L) {
        var mh$ = lua_pushthread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pushthread", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getglobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_getglobal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_getglobal)(lua_State *L, const char *name)
     * }
     */
    public static FunctionDescriptor lua_getglobal$descriptor() {
        return lua_getglobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_getglobal)(lua_State *L, const char *name)
     * }
     */
    public static MethodHandle lua_getglobal$handle() {
        return lua_getglobal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_getglobal)(lua_State *L, const char *name)
     * }
     */
    public static int lua_getglobal(MemorySegment L, MemorySegment name) {
        var mh$ = lua_getglobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getglobal", L, name);
            }
            return (int)mh$.invokeExact(L, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_gettable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_gettable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_gettable)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_gettable$descriptor() {
        return lua_gettable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_gettable)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_gettable$handle() {
        return lua_gettable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_gettable)(lua_State *L, int idx)
     * }
     */
    public static int lua_gettable(MemorySegment L, int idx) {
        var mh$ = lua_gettable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_gettable", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getfield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_getfield"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_getfield)(lua_State *L, int idx, const char *k)
     * }
     */
    public static FunctionDescriptor lua_getfield$descriptor() {
        return lua_getfield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_getfield)(lua_State *L, int idx, const char *k)
     * }
     */
    public static MethodHandle lua_getfield$handle() {
        return lua_getfield.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_getfield)(lua_State *L, int idx, const char *k)
     * }
     */
    public static int lua_getfield(MemorySegment L, int idx, MemorySegment k) {
        var mh$ = lua_getfield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getfield", L, idx, k);
            }
            return (int)mh$.invokeExact(L, idx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_geti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_geti"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_geti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static FunctionDescriptor lua_geti$descriptor() {
        return lua_geti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_geti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static MethodHandle lua_geti$handle() {
        return lua_geti.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_geti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static int lua_geti(MemorySegment L, int idx, long n) {
        var mh$ = lua_geti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_geti", L, idx, n);
            }
            return (int)mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_rawget"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_rawget)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_rawget$descriptor() {
        return lua_rawget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_rawget)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_rawget$handle() {
        return lua_rawget.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_rawget)(lua_State *L, int idx)
     * }
     */
    public static int lua_rawget(MemorySegment L, int idx) {
        var mh$ = lua_rawget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawget", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawgeti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_rawgeti"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_rawgeti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static FunctionDescriptor lua_rawgeti$descriptor() {
        return lua_rawgeti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_rawgeti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static MethodHandle lua_rawgeti$handle() {
        return lua_rawgeti.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_rawgeti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static int lua_rawgeti(MemorySegment L, int idx, long n) {
        var mh$ = lua_rawgeti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawgeti", L, idx, n);
            }
            return (int)mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawgetp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_rawgetp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_rawgetp)(lua_State *L, int idx, const void *p)
     * }
     */
    public static FunctionDescriptor lua_rawgetp$descriptor() {
        return lua_rawgetp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_rawgetp)(lua_State *L, int idx, const void *p)
     * }
     */
    public static MethodHandle lua_rawgetp$handle() {
        return lua_rawgetp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_rawgetp)(lua_State *L, int idx, const void *p)
     * }
     */
    public static int lua_rawgetp(MemorySegment L, int idx, MemorySegment p) {
        var mh$ = lua_rawgetp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawgetp", L, idx, p);
            }
            return (int)mh$.invokeExact(L, idx, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_createtable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_createtable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_createtable)(lua_State *L, int narr, int nrec)
     * }
     */
    public static FunctionDescriptor lua_createtable$descriptor() {
        return lua_createtable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_createtable)(lua_State *L, int narr, int nrec)
     * }
     */
    public static MethodHandle lua_createtable$handle() {
        return lua_createtable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_createtable)(lua_State *L, int narr, int nrec)
     * }
     */
    public static void lua_createtable(MemorySegment L, int narr, int nrec) {
        var mh$ = lua_createtable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_createtable", L, narr, nrec);
            }
            mh$.invokeExact(L, narr, nrec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_newuserdatauv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_LONG_LONG,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_newuserdatauv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *(lua_newuserdatauv)(lua_State *L, size_t sz, int nuvalue)
     * }
     */
    public static FunctionDescriptor lua_newuserdatauv$descriptor() {
        return lua_newuserdatauv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *(lua_newuserdatauv)(lua_State *L, size_t sz, int nuvalue)
     * }
     */
    public static MethodHandle lua_newuserdatauv$handle() {
        return lua_newuserdatauv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *(lua_newuserdatauv)(lua_State *L, size_t sz, int nuvalue)
     * }
     */
    public static MemorySegment lua_newuserdatauv(MemorySegment L, long sz, int nuvalue) {
        var mh$ = lua_newuserdatauv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_newuserdatauv", L, sz, nuvalue);
            }
            return (MemorySegment)mh$.invokeExact(L, sz, nuvalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getmetatable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_getmetatable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_getmetatable)(lua_State *L, int objindex)
     * }
     */
    public static FunctionDescriptor lua_getmetatable$descriptor() {
        return lua_getmetatable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_getmetatable)(lua_State *L, int objindex)
     * }
     */
    public static MethodHandle lua_getmetatable$handle() {
        return lua_getmetatable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_getmetatable)(lua_State *L, int objindex)
     * }
     */
    public static int lua_getmetatable(MemorySegment L, int objindex) {
        var mh$ = lua_getmetatable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getmetatable", L, objindex);
            }
            return (int)mh$.invokeExact(L, objindex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getiuservalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_getiuservalue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_getiuservalue)(lua_State *L, int idx, int n)
     * }
     */
    public static FunctionDescriptor lua_getiuservalue$descriptor() {
        return lua_getiuservalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_getiuservalue)(lua_State *L, int idx, int n)
     * }
     */
    public static MethodHandle lua_getiuservalue$handle() {
        return lua_getiuservalue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_getiuservalue)(lua_State *L, int idx, int n)
     * }
     */
    public static int lua_getiuservalue(MemorySegment L, int idx, int n) {
        var mh$ = lua_getiuservalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getiuservalue", L, idx, n);
            }
            return (int)mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setglobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_setglobal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_setglobal)(lua_State *L, const char *name)
     * }
     */
    public static FunctionDescriptor lua_setglobal$descriptor() {
        return lua_setglobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_setglobal)(lua_State *L, const char *name)
     * }
     */
    public static MethodHandle lua_setglobal$handle() {
        return lua_setglobal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_setglobal)(lua_State *L, const char *name)
     * }
     */
    public static void lua_setglobal(MemorySegment L, MemorySegment name) {
        var mh$ = lua_setglobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setglobal", L, name);
            }
            mh$.invokeExact(L, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_settable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_settable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_settable)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_settable$descriptor() {
        return lua_settable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_settable)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_settable$handle() {
        return lua_settable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_settable)(lua_State *L, int idx)
     * }
     */
    public static void lua_settable(MemorySegment L, int idx) {
        var mh$ = lua_settable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_settable", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setfield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_setfield"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_setfield)(lua_State *L, int idx, const char *k)
     * }
     */
    public static FunctionDescriptor lua_setfield$descriptor() {
        return lua_setfield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_setfield)(lua_State *L, int idx, const char *k)
     * }
     */
    public static MethodHandle lua_setfield$handle() {
        return lua_setfield.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_setfield)(lua_State *L, int idx, const char *k)
     * }
     */
    public static void lua_setfield(MemorySegment L, int idx, MemorySegment k) {
        var mh$ = lua_setfield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setfield", L, idx, k);
            }
            mh$.invokeExact(L, idx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_seti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_seti"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_seti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static FunctionDescriptor lua_seti$descriptor() {
        return lua_seti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_seti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static MethodHandle lua_seti$handle() {
        return lua_seti.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_seti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static void lua_seti(MemorySegment L, int idx, long n) {
        var mh$ = lua_seti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_seti", L, idx, n);
            }
            mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_rawset"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_rawset)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_rawset$descriptor() {
        return lua_rawset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_rawset)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_rawset$handle() {
        return lua_rawset.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_rawset)(lua_State *L, int idx)
     * }
     */
    public static void lua_rawset(MemorySegment L, int idx) {
        var mh$ = lua_rawset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawset", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawseti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_rawseti"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_rawseti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static FunctionDescriptor lua_rawseti$descriptor() {
        return lua_rawseti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_rawseti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static MethodHandle lua_rawseti$handle() {
        return lua_rawseti.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_rawseti)(lua_State *L, int idx, lua_Integer n)
     * }
     */
    public static void lua_rawseti(MemorySegment L, int idx, long n) {
        var mh$ = lua_rawseti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawseti", L, idx, n);
            }
            mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_rawsetp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_rawsetp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_rawsetp)(lua_State *L, int idx, const void *p)
     * }
     */
    public static FunctionDescriptor lua_rawsetp$descriptor() {
        return lua_rawsetp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_rawsetp)(lua_State *L, int idx, const void *p)
     * }
     */
    public static MethodHandle lua_rawsetp$handle() {
        return lua_rawsetp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_rawsetp)(lua_State *L, int idx, const void *p)
     * }
     */
    public static void lua_rawsetp(MemorySegment L, int idx, MemorySegment p) {
        var mh$ = lua_rawsetp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_rawsetp", L, idx, p);
            }
            mh$.invokeExact(L, idx, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setmetatable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_setmetatable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_setmetatable)(lua_State *L, int objindex)
     * }
     */
    public static FunctionDescriptor lua_setmetatable$descriptor() {
        return lua_setmetatable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_setmetatable)(lua_State *L, int objindex)
     * }
     */
    public static MethodHandle lua_setmetatable$handle() {
        return lua_setmetatable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_setmetatable)(lua_State *L, int objindex)
     * }
     */
    public static int lua_setmetatable(MemorySegment L, int objindex) {
        var mh$ = lua_setmetatable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setmetatable", L, objindex);
            }
            return (int)mh$.invokeExact(L, objindex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setiuservalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_setiuservalue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_setiuservalue)(lua_State *L, int idx, int n)
     * }
     */
    public static FunctionDescriptor lua_setiuservalue$descriptor() {
        return lua_setiuservalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_setiuservalue)(lua_State *L, int idx, int n)
     * }
     */
    public static MethodHandle lua_setiuservalue$handle() {
        return lua_setiuservalue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_setiuservalue)(lua_State *L, int idx, int n)
     * }
     */
    public static int lua_setiuservalue(MemorySegment L, int idx, int n) {
        var mh$ = lua_setiuservalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setiuservalue", L, idx, n);
            }
            return (int)mh$.invokeExact(L, idx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_callk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_INT,
            lualib_h.C_LONG_LONG,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_callk"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_callk)(lua_State *L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static FunctionDescriptor lua_callk$descriptor() {
        return lua_callk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_callk)(lua_State *L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static MethodHandle lua_callk$handle() {
        return lua_callk.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_callk)(lua_State *L, int nargs, int nresults, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static void lua_callk(MemorySegment L, int nargs, int nresults, long ctx, MemorySegment k) {
        var mh$ = lua_callk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_callk", L, nargs, nresults, ctx, k);
            }
            mh$.invokeExact(L, nargs, nresults, ctx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_pcallk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_INT,
            lualib_h.C_INT,
            lualib_h.C_LONG_LONG,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_pcallk"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_pcallk)(lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static FunctionDescriptor lua_pcallk$descriptor() {
        return lua_pcallk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_pcallk)(lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static MethodHandle lua_pcallk$handle() {
        return lua_pcallk.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_pcallk)(lua_State *L, int nargs, int nresults, int errfunc, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static int lua_pcallk(MemorySegment L, int nargs, int nresults, int errfunc, long ctx, MemorySegment k) {
        var mh$ = lua_pcallk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_pcallk", L, nargs, nresults, errfunc, ctx, k);
            }
            return (int)mh$.invokeExact(L, nargs, nresults, errfunc, ctx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_load {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_load"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_load)(lua_State *L, lua_Reader reader, void *dt, const char *chunkname, const char *mode)
     * }
     */
    public static FunctionDescriptor lua_load$descriptor() {
        return lua_load.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_load)(lua_State *L, lua_Reader reader, void *dt, const char *chunkname, const char *mode)
     * }
     */
    public static MethodHandle lua_load$handle() {
        return lua_load.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_load)(lua_State *L, lua_Reader reader, void *dt, const char *chunkname, const char *mode)
     * }
     */
    public static int lua_load(MemorySegment L, MemorySegment reader, MemorySegment dt, MemorySegment chunkname, MemorySegment mode) {
        var mh$ = lua_load.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_load", L, reader, dt, chunkname, mode);
            }
            return (int)mh$.invokeExact(L, reader, dt, chunkname, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_dump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_dump"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_dump)(lua_State *L, lua_Writer writer, void *data, int strip)
     * }
     */
    public static FunctionDescriptor lua_dump$descriptor() {
        return lua_dump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_dump)(lua_State *L, lua_Writer writer, void *data, int strip)
     * }
     */
    public static MethodHandle lua_dump$handle() {
        return lua_dump.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_dump)(lua_State *L, lua_Writer writer, void *data, int strip)
     * }
     */
    public static int lua_dump(MemorySegment L, MemorySegment writer, MemorySegment data, int strip) {
        var mh$ = lua_dump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_dump", L, writer, data, strip);
            }
            return (int)mh$.invokeExact(L, writer, data, strip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_yieldk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_LONG_LONG,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_yieldk"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_yieldk)(lua_State *L, int nresults, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static FunctionDescriptor lua_yieldk$descriptor() {
        return lua_yieldk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_yieldk)(lua_State *L, int nresults, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static MethodHandle lua_yieldk$handle() {
        return lua_yieldk.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_yieldk)(lua_State *L, int nresults, lua_KContext ctx, lua_KFunction k)
     * }
     */
    public static int lua_yieldk(MemorySegment L, int nresults, long ctx, MemorySegment k) {
        var mh$ = lua_yieldk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_yieldk", L, nresults, ctx, k);
            }
            return (int)mh$.invokeExact(L, nresults, ctx, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_resume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_resume"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_resume)(lua_State *L, lua_State *from, int narg, int *nres)
     * }
     */
    public static FunctionDescriptor lua_resume$descriptor() {
        return lua_resume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_resume)(lua_State *L, lua_State *from, int narg, int *nres)
     * }
     */
    public static MethodHandle lua_resume$handle() {
        return lua_resume.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_resume)(lua_State *L, lua_State *from, int narg, int *nres)
     * }
     */
    public static int lua_resume(MemorySegment L, MemorySegment from, int narg, MemorySegment nres) {
        var mh$ = lua_resume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_resume", L, from, narg, nres);
            }
            return (int)mh$.invokeExact(L, from, narg, nres);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_status {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_status"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_status)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_status$descriptor() {
        return lua_status.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_status)(lua_State *L)
     * }
     */
    public static MethodHandle lua_status$handle() {
        return lua_status.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_status)(lua_State *L)
     * }
     */
    public static int lua_status(MemorySegment L) {
        var mh$ = lua_status.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_status", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_isyieldable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_isyieldable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_isyieldable)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_isyieldable$descriptor() {
        return lua_isyieldable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_isyieldable)(lua_State *L)
     * }
     */
    public static MethodHandle lua_isyieldable$handle() {
        return lua_isyieldable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_isyieldable)(lua_State *L)
     * }
     */
    public static int lua_isyieldable(MemorySegment L) {
        var mh$ = lua_isyieldable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_isyieldable", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setwarnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_setwarnf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_setwarnf)(lua_State *L, lua_WarnFunction f, void *ud)
     * }
     */
    public static FunctionDescriptor lua_setwarnf$descriptor() {
        return lua_setwarnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_setwarnf)(lua_State *L, lua_WarnFunction f, void *ud)
     * }
     */
    public static MethodHandle lua_setwarnf$handle() {
        return lua_setwarnf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_setwarnf)(lua_State *L, lua_WarnFunction f, void *ud)
     * }
     */
    public static void lua_setwarnf(MemorySegment L, MemorySegment f, MemorySegment ud) {
        var mh$ = lua_setwarnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setwarnf", L, f, ud);
            }
            mh$.invokeExact(L, f, ud);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_warning {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_warning"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_warning)(lua_State *L, const char *msg, int tocont)
     * }
     */
    public static FunctionDescriptor lua_warning$descriptor() {
        return lua_warning.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_warning)(lua_State *L, const char *msg, int tocont)
     * }
     */
    public static MethodHandle lua_warning$handle() {
        return lua_warning.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_warning)(lua_State *L, const char *msg, int tocont)
     * }
     */
    public static void lua_warning(MemorySegment L, MemorySegment msg, int tocont) {
        var mh$ = lua_warning.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_warning", L, msg, tocont);
            }
            mh$.invokeExact(L, msg, tocont);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int (lua_gc)(lua_State *L, int what, ...)
     * }
     */
    public static class lua_gc {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                lualib_h.C_INT,
                lualib_h.C_POINTER,
                lualib_h.C_INT
            );
        private static final MemorySegment ADDR = lualib_h.findOrThrow("lua_gc");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private lua_gc(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int (lua_gc)(lua_State *L, int what, ...)
         * }
         */
        public static lua_gc makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new lua_gc(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment L, int what, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("lua_gc", L, what, x2);
                }
                return (int)spreader.invokeExact(L, what, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class lua_error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_error"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_error)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_error$descriptor() {
        return lua_error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_error)(lua_State *L)
     * }
     */
    public static MethodHandle lua_error$handle() {
        return lua_error.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_error)(lua_State *L)
     * }
     */
    public static int lua_error(MemorySegment L) {
        var mh$ = lua_error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_error", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_next"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_next)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_next$descriptor() {
        return lua_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_next)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_next$handle() {
        return lua_next.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_next)(lua_State *L, int idx)
     * }
     */
    public static int lua_next(MemorySegment L, int idx) {
        var mh$ = lua_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_next", L, idx);
            }
            return (int)mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_concat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_concat)(lua_State *L, int n)
     * }
     */
    public static FunctionDescriptor lua_concat$descriptor() {
        return lua_concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_concat)(lua_State *L, int n)
     * }
     */
    public static MethodHandle lua_concat$handle() {
        return lua_concat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_concat)(lua_State *L, int n)
     * }
     */
    public static void lua_concat(MemorySegment L, int n) {
        var mh$ = lua_concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_concat", L, n);
            }
            mh$.invokeExact(L, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_len {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_len"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_len)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_len$descriptor() {
        return lua_len.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_len)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_len$handle() {
        return lua_len.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_len)(lua_State *L, int idx)
     * }
     */
    public static void lua_len(MemorySegment L, int idx) {
        var mh$ = lua_len.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_len", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_stringtonumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_LONG_LONG,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_stringtonumber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t (lua_stringtonumber)(lua_State *L, const char *s)
     * }
     */
    public static FunctionDescriptor lua_stringtonumber$descriptor() {
        return lua_stringtonumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t (lua_stringtonumber)(lua_State *L, const char *s)
     * }
     */
    public static MethodHandle lua_stringtonumber$handle() {
        return lua_stringtonumber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern size_t (lua_stringtonumber)(lua_State *L, const char *s)
     * }
     */
    public static long lua_stringtonumber(MemorySegment L, MemorySegment s) {
        var mh$ = lua_stringtonumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_stringtonumber", L, s);
            }
            return (long)mh$.invokeExact(L, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_getallocf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Alloc (lua_getallocf)(lua_State *L, void **ud)
     * }
     */
    public static FunctionDescriptor lua_getallocf$descriptor() {
        return lua_getallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Alloc (lua_getallocf)(lua_State *L, void **ud)
     * }
     */
    public static MethodHandle lua_getallocf$handle() {
        return lua_getallocf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Alloc (lua_getallocf)(lua_State *L, void **ud)
     * }
     */
    public static MemorySegment lua_getallocf(MemorySegment L, MemorySegment ud) {
        var mh$ = lua_getallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getallocf", L, ud);
            }
            return (MemorySegment)mh$.invokeExact(L, ud);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_setallocf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_setallocf)(lua_State *L, lua_Alloc f, void *ud)
     * }
     */
    public static FunctionDescriptor lua_setallocf$descriptor() {
        return lua_setallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_setallocf)(lua_State *L, lua_Alloc f, void *ud)
     * }
     */
    public static MethodHandle lua_setallocf$handle() {
        return lua_setallocf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_setallocf)(lua_State *L, lua_Alloc f, void *ud)
     * }
     */
    public static void lua_setallocf(MemorySegment L, MemorySegment f, MemorySegment ud) {
        var mh$ = lua_setallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setallocf", L, f, ud);
            }
            mh$.invokeExact(L, f, ud);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_toclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_toclose"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_toclose)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_toclose$descriptor() {
        return lua_toclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_toclose)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_toclose$handle() {
        return lua_toclose.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_toclose)(lua_State *L, int idx)
     * }
     */
    public static void lua_toclose(MemorySegment L, int idx) {
        var mh$ = lua_toclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_toclose", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_closeslot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_closeslot"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_closeslot)(lua_State *L, int idx)
     * }
     */
    public static FunctionDescriptor lua_closeslot$descriptor() {
        return lua_closeslot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_closeslot)(lua_State *L, int idx)
     * }
     */
    public static MethodHandle lua_closeslot$handle() {
        return lua_closeslot.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_closeslot)(lua_State *L, int idx)
     * }
     */
    public static void lua_closeslot(MemorySegment L, int idx) {
        var mh$ = lua_closeslot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_closeslot", L, idx);
            }
            mh$.invokeExact(L, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getstack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_getstack"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_getstack)(lua_State *L, int level, lua_Debug *ar)
     * }
     */
    public static FunctionDescriptor lua_getstack$descriptor() {
        return lua_getstack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_getstack)(lua_State *L, int level, lua_Debug *ar)
     * }
     */
    public static MethodHandle lua_getstack$handle() {
        return lua_getstack.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_getstack)(lua_State *L, int level, lua_Debug *ar)
     * }
     */
    public static int lua_getstack(MemorySegment L, int level, MemorySegment ar) {
        var mh$ = lua_getstack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getstack", L, level, ar);
            }
            return (int)mh$.invokeExact(L, level, ar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_getinfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_getinfo)(lua_State *L, const char *what, lua_Debug *ar)
     * }
     */
    public static FunctionDescriptor lua_getinfo$descriptor() {
        return lua_getinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_getinfo)(lua_State *L, const char *what, lua_Debug *ar)
     * }
     */
    public static MethodHandle lua_getinfo$handle() {
        return lua_getinfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_getinfo)(lua_State *L, const char *what, lua_Debug *ar)
     * }
     */
    public static int lua_getinfo(MemorySegment L, MemorySegment what, MemorySegment ar) {
        var mh$ = lua_getinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getinfo", L, what, ar);
            }
            return (int)mh$.invokeExact(L, what, ar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getlocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_getlocal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_getlocal)(lua_State *L, const lua_Debug *ar, int n)
     * }
     */
    public static FunctionDescriptor lua_getlocal$descriptor() {
        return lua_getlocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_getlocal)(lua_State *L, const lua_Debug *ar, int n)
     * }
     */
    public static MethodHandle lua_getlocal$handle() {
        return lua_getlocal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_getlocal)(lua_State *L, const lua_Debug *ar, int n)
     * }
     */
    public static MemorySegment lua_getlocal(MemorySegment L, MemorySegment ar, int n) {
        var mh$ = lua_getlocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getlocal", L, ar, n);
            }
            return (MemorySegment)mh$.invokeExact(L, ar, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setlocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_setlocal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_setlocal)(lua_State *L, const lua_Debug *ar, int n)
     * }
     */
    public static FunctionDescriptor lua_setlocal$descriptor() {
        return lua_setlocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_setlocal)(lua_State *L, const lua_Debug *ar, int n)
     * }
     */
    public static MethodHandle lua_setlocal$handle() {
        return lua_setlocal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_setlocal)(lua_State *L, const lua_Debug *ar, int n)
     * }
     */
    public static MemorySegment lua_setlocal(MemorySegment L, MemorySegment ar, int n) {
        var mh$ = lua_setlocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setlocal", L, ar, n);
            }
            return (MemorySegment)mh$.invokeExact(L, ar, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_getupvalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_getupvalue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_getupvalue)(lua_State *L, int funcindex, int n)
     * }
     */
    public static FunctionDescriptor lua_getupvalue$descriptor() {
        return lua_getupvalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_getupvalue)(lua_State *L, int funcindex, int n)
     * }
     */
    public static MethodHandle lua_getupvalue$handle() {
        return lua_getupvalue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_getupvalue)(lua_State *L, int funcindex, int n)
     * }
     */
    public static MemorySegment lua_getupvalue(MemorySegment L, int funcindex, int n) {
        var mh$ = lua_getupvalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_getupvalue", L, funcindex, n);
            }
            return (MemorySegment)mh$.invokeExact(L, funcindex, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setupvalue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_setupvalue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *(lua_setupvalue)(lua_State *L, int funcindex, int n)
     * }
     */
    public static FunctionDescriptor lua_setupvalue$descriptor() {
        return lua_setupvalue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *(lua_setupvalue)(lua_State *L, int funcindex, int n)
     * }
     */
    public static MethodHandle lua_setupvalue$handle() {
        return lua_setupvalue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern const char *(lua_setupvalue)(lua_State *L, int funcindex, int n)
     * }
     */
    public static MemorySegment lua_setupvalue(MemorySegment L, int funcindex, int n) {
        var mh$ = lua_setupvalue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setupvalue", L, funcindex, n);
            }
            return (MemorySegment)mh$.invokeExact(L, funcindex, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_upvalueid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_upvalueid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *(lua_upvalueid)(lua_State *L, int fidx, int n)
     * }
     */
    public static FunctionDescriptor lua_upvalueid$descriptor() {
        return lua_upvalueid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *(lua_upvalueid)(lua_State *L, int fidx, int n)
     * }
     */
    public static MethodHandle lua_upvalueid$handle() {
        return lua_upvalueid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *(lua_upvalueid)(lua_State *L, int fidx, int n)
     * }
     */
    public static MemorySegment lua_upvalueid(MemorySegment L, int fidx, int n) {
        var mh$ = lua_upvalueid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_upvalueid", L, fidx, n);
            }
            return (MemorySegment)mh$.invokeExact(L, fidx, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_upvaluejoin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_INT,
            lualib_h.C_INT,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_upvaluejoin"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_upvaluejoin)(lua_State *L, int fidx1, int n1, int fidx2, int n2)
     * }
     */
    public static FunctionDescriptor lua_upvaluejoin$descriptor() {
        return lua_upvaluejoin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_upvaluejoin)(lua_State *L, int fidx1, int n1, int fidx2, int n2)
     * }
     */
    public static MethodHandle lua_upvaluejoin$handle() {
        return lua_upvaluejoin.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_upvaluejoin)(lua_State *L, int fidx1, int n1, int fidx2, int n2)
     * }
     */
    public static void lua_upvaluejoin(MemorySegment L, int fidx1, int n1, int fidx2, int n2) {
        var mh$ = lua_upvaluejoin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_upvaluejoin", L, fidx1, n1, fidx2, n2);
            }
            mh$.invokeExact(L, fidx1, n1, fidx2, n2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_sethook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER,
            lualib_h.C_INT,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_sethook"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (lua_sethook)(lua_State *L, lua_Hook func, int mask, int count)
     * }
     */
    public static FunctionDescriptor lua_sethook$descriptor() {
        return lua_sethook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (lua_sethook)(lua_State *L, lua_Hook func, int mask, int count)
     * }
     */
    public static MethodHandle lua_sethook$handle() {
        return lua_sethook.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (lua_sethook)(lua_State *L, lua_Hook func, int mask, int count)
     * }
     */
    public static void lua_sethook(MemorySegment L, MemorySegment func, int mask, int count) {
        var mh$ = lua_sethook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_sethook", L, func, mask, count);
            }
            mh$.invokeExact(L, func, mask, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_gethook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_POINTER,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_gethook"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lua_Hook (lua_gethook)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_gethook$descriptor() {
        return lua_gethook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lua_Hook (lua_gethook)(lua_State *L)
     * }
     */
    public static MethodHandle lua_gethook$handle() {
        return lua_gethook.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern lua_Hook (lua_gethook)(lua_State *L)
     * }
     */
    public static MemorySegment lua_gethook(MemorySegment L) {
        var mh$ = lua_gethook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_gethook", L);
            }
            return (MemorySegment)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_gethookmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_gethookmask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_gethookmask)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_gethookmask$descriptor() {
        return lua_gethookmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_gethookmask)(lua_State *L)
     * }
     */
    public static MethodHandle lua_gethookmask$handle() {
        return lua_gethookmask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_gethookmask)(lua_State *L)
     * }
     */
    public static int lua_gethookmask(MemorySegment L) {
        var mh$ = lua_gethookmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_gethookmask", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_gethookcount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_gethookcount"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_gethookcount)(lua_State *L)
     * }
     */
    public static FunctionDescriptor lua_gethookcount$descriptor() {
        return lua_gethookcount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_gethookcount)(lua_State *L)
     * }
     */
    public static MethodHandle lua_gethookcount$handle() {
        return lua_gethookcount.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_gethookcount)(lua_State *L)
     * }
     */
    public static int lua_gethookcount(MemorySegment L) {
        var mh$ = lua_gethookcount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_gethookcount", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lua_setcstacklimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER,
            lualib_h.C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("lua_setcstacklimit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (lua_setcstacklimit)(lua_State *L, unsigned int limit)
     * }
     */
    public static FunctionDescriptor lua_setcstacklimit$descriptor() {
        return lua_setcstacklimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (lua_setcstacklimit)(lua_State *L, unsigned int limit)
     * }
     */
    public static MethodHandle lua_setcstacklimit$handle() {
        return lua_setcstacklimit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (lua_setcstacklimit)(lua_State *L, unsigned int limit)
     * }
     */
    public static int lua_setcstacklimit(MemorySegment L, int limit) {
        var mh$ = lua_setcstacklimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lua_setcstacklimit", L, limit);
            }
            return (int)mh$.invokeExact(L, limit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("luaopen_base"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_base)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_base$descriptor() {
        return luaopen_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_base)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_base$handle() {
        return luaopen_base.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_base)(lua_State *L)
     * }
     */
    public static int luaopen_base(MemorySegment L) {
        var mh$ = luaopen_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_base", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_coroutine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("luaopen_coroutine"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_coroutine)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_coroutine$descriptor() {
        return luaopen_coroutine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_coroutine)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_coroutine$handle() {
        return luaopen_coroutine.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_coroutine)(lua_State *L)
     * }
     */
    public static int luaopen_coroutine(MemorySegment L) {
        var mh$ = luaopen_coroutine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_coroutine", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_table {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("luaopen_table"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_table)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_table$descriptor() {
        return luaopen_table.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_table)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_table$handle() {
        return luaopen_table.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_table)(lua_State *L)
     * }
     */
    public static int luaopen_table(MemorySegment L) {
        var mh$ = luaopen_table.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_table", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_io {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("luaopen_io"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_io)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_io$descriptor() {
        return luaopen_io.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_io)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_io$handle() {
        return luaopen_io.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_io)(lua_State *L)
     * }
     */
    public static int luaopen_io(MemorySegment L) {
        var mh$ = luaopen_io.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_io", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_os {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("luaopen_os"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_os)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_os$descriptor() {
        return luaopen_os.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_os)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_os$handle() {
        return luaopen_os.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_os)(lua_State *L)
     * }
     */
    public static int luaopen_os(MemorySegment L) {
        var mh$ = luaopen_os.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_os", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("luaopen_string"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_string)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_string$descriptor() {
        return luaopen_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_string)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_string$handle() {
        return luaopen_string.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_string)(lua_State *L)
     * }
     */
    public static int luaopen_string(MemorySegment L) {
        var mh$ = luaopen_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_string", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("luaopen_utf8"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_utf8)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_utf8$descriptor() {
        return luaopen_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_utf8)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_utf8$handle() {
        return luaopen_utf8.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_utf8)(lua_State *L)
     * }
     */
    public static int luaopen_utf8(MemorySegment L) {
        var mh$ = luaopen_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_utf8", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_math {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("luaopen_math"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_math)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_math$descriptor() {
        return luaopen_math.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_math)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_math$handle() {
        return luaopen_math.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_math)(lua_State *L)
     * }
     */
    public static int luaopen_math(MemorySegment L) {
        var mh$ = luaopen_math.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_math", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_debug {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("luaopen_debug"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_debug)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_debug$descriptor() {
        return luaopen_debug.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_debug)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_debug$handle() {
        return luaopen_debug.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_debug)(lua_State *L)
     * }
     */
    public static int luaopen_debug(MemorySegment L) {
        var mh$ = luaopen_debug.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_debug", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaopen_package {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lualib_h.C_INT,
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("luaopen_package"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int (luaopen_package)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaopen_package$descriptor() {
        return luaopen_package.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int (luaopen_package)(lua_State *L)
     * }
     */
    public static MethodHandle luaopen_package$handle() {
        return luaopen_package.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int (luaopen_package)(lua_State *L)
     * }
     */
    public static int luaopen_package(MemorySegment L) {
        var mh$ = luaopen_package.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaopen_package", L);
            }
            return (int)mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class luaL_openlibs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            lualib_h.C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    lualib_h.findOrThrow("luaL_openlibs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void (luaL_openlibs)(lua_State *L)
     * }
     */
    public static FunctionDescriptor luaL_openlibs$descriptor() {
        return luaL_openlibs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void (luaL_openlibs)(lua_State *L)
     * }
     */
    public static MethodHandle luaL_openlibs$handle() {
        return luaL_openlibs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void (luaL_openlibs)(lua_State *L)
     * }
     */
    public static void luaL_openlibs(MemorySegment L) {
        var mh$ = luaL_openlibs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("luaL_openlibs", L);
            }
            mh$.invokeExact(L);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int _VCRUNTIME_DISABLED_WARNINGS = (int)4514L;
    /**
     * {@snippet lang=c :
     * #define _VCRUNTIME_DISABLED_WARNINGS 4514
     * }
     */
    public static int _VCRUNTIME_DISABLED_WARNINGS() {
        return _VCRUNTIME_DISABLED_WARNINGS;
    }
    private static final int SCHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MIN -128
     * }
     */
    public static int SCHAR_MIN() {
        return SCHAR_MIN;
    }
    private static final int CHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MIN -128
     * }
     */
    public static int CHAR_MIN() {
        return CHAR_MIN;
    }
    private static final int CHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MAX 127
     * }
     */
    public static int CHAR_MAX() {
        return CHAR_MAX;
    }
    private static final int SHRT_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MIN -32768
     * }
     */
    public static int SHRT_MIN() {
        return SHRT_MIN;
    }
    private static final int INT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_MIN -2147483648
     * }
     */
    public static int INT_MIN() {
        return INT_MIN;
    }
    private static final int UINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_MAX 4294967295
     * }
     */
    public static int UINT_MAX() {
        return UINT_MAX;
    }
    private static final int LONG_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define LONG_MIN -2147483648
     * }
     */
    public static int LONG_MIN() {
        return LONG_MIN;
    }
    private static final int LONG_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define LONG_MAX 2147483647
     * }
     */
    public static int LONG_MAX() {
        return LONG_MAX;
    }
    private static final int ULONG_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define ULONG_MAX 4294967295
     * }
     */
    public static int ULONG_MAX() {
        return ULONG_MAX;
    }
    private static final long LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MAX 9223372036854775807
     * }
     */
    public static long LLONG_MAX() {
        return LLONG_MAX;
    }
    private static final long LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MIN -9223372036854775808
     * }
     */
    public static long LLONG_MIN() {
        return LLONG_MIN;
    }
    private static final long ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULLONG_MAX -1
     * }
     */
    public static long ULLONG_MAX() {
        return ULLONG_MAX;
    }
    private static final int _I8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define _I8_MIN -128
     * }
     */
    public static int _I8_MIN() {
        return _I8_MIN;
    }
    private static final byte _I8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define _I8_MAX 127
     * }
     */
    public static byte _I8_MAX() {
        return _I8_MAX;
    }
    private static final byte _UI8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define _UI8_MAX 255
     * }
     */
    public static byte _UI8_MAX() {
        return _UI8_MAX;
    }
    private static final int _I16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define _I16_MIN -32768
     * }
     */
    public static int _I16_MIN() {
        return _I16_MIN;
    }
    private static final short _I16_MAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define _I16_MAX 32767
     * }
     */
    public static short _I16_MAX() {
        return _I16_MAX;
    }
    private static final short _UI16_MAX = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define _UI16_MAX 65535
     * }
     */
    public static short _UI16_MAX() {
        return _UI16_MAX;
    }
    private static final int _I32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define _I32_MIN -2147483648
     * }
     */
    public static int _I32_MIN() {
        return _I32_MIN;
    }
    private static final int _I32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _I32_MAX 2147483647
     * }
     */
    public static int _I32_MAX() {
        return _I32_MAX;
    }
    private static final int _UI32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define _UI32_MAX 4294967295
     * }
     */
    public static int _UI32_MAX() {
        return _UI32_MAX;
    }
    private static final long _I64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define _I64_MIN -9223372036854775808
     * }
     */
    public static long _I64_MIN() {
        return _I64_MIN;
    }
    private static final long _I64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define _I64_MAX 9223372036854775807
     * }
     */
    public static long _I64_MAX() {
        return _I64_MAX;
    }
    private static final long _UI64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define _UI64_MAX -1
     * }
     */
    public static long _UI64_MAX() {
        return _UI64_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long LONG_LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_LONG_MAX() {
        return LONG_LONG_MAX;
    }
    private static final long LONG_LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_LONG_MIN() {
        return LONG_LONG_MIN;
    }
    private static final long ULONG_LONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_LONG_MAX -1
     * }
     */
    public static long ULONG_LONG_MAX() {
        return ULONG_LONG_MAX;
    }
    private static final int LUAI_IS32INT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUAI_IS32INT 1
     * }
     */
    public static int LUAI_IS32INT() {
        return LUAI_IS32INT;
    }
    private static final int LUA_INT_DEFAULT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_INT_DEFAULT 3
     * }
     */
    public static int LUA_INT_DEFAULT() {
        return LUA_INT_DEFAULT;
    }
    private static final int LUA_FLOAT_DEFAULT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_FLOAT_DEFAULT 2
     * }
     */
    public static int LUA_FLOAT_DEFAULT() {
        return LUA_FLOAT_DEFAULT;
    }
    private static final int LUA_INT_TYPE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LUA_INT_TYPE 3
     * }
     */
    public static int LUA_INT_TYPE() {
        return LUA_INT_TYPE;
    }
    private static final int LUA_FLOAT_TYPE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_FLOAT_TYPE 2
     * }
     */
    public static int LUA_FLOAT_TYPE() {
        return LUA_FLOAT_TYPE;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_PATH_SEP ";"
     * }
     */
    public static MemorySegment LUA_PATH_SEP() {
        class Holder {
            static final MemorySegment LUA_PATH_SEP
                = lualib_h.LIBRARY_ARENA.allocateFrom(";");
        }
        return Holder.LUA_PATH_SEP;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_PATH_MARK "?"
     * }
     */
    public static MemorySegment LUA_PATH_MARK() {
        class Holder {
            static final MemorySegment LUA_PATH_MARK
                = lualib_h.LIBRARY_ARENA.allocateFrom("?");
        }
        return Holder.LUA_PATH_MARK;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_EXEC_DIR "!"
     * }
     */
    public static MemorySegment LUA_EXEC_DIR() {
        class Holder {
            static final MemorySegment LUA_EXEC_DIR
                = lualib_h.LIBRARY_ARENA.allocateFrom("!");
        }
        return Holder.LUA_EXEC_DIR;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_VDIR "5.4"
     * }
     */
    public static MemorySegment LUA_VDIR() {
        class Holder {
            static final MemorySegment LUA_VDIR
                = lualib_h.LIBRARY_ARENA.allocateFrom("5.4");
        }
        return Holder.LUA_VDIR;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_LDIR "!\lua\"
     * }
     */
    public static MemorySegment LUA_LDIR() {
        class Holder {
            static final MemorySegment LUA_LDIR
                = lualib_h.LIBRARY_ARENA.allocateFrom("!\\lua\\");
        }
        return Holder.LUA_LDIR;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_CDIR "!\"
     * }
     */
    public static MemorySegment LUA_CDIR() {
        class Holder {
            static final MemorySegment LUA_CDIR
                = lualib_h.LIBRARY_ARENA.allocateFrom("!\\");
        }
        return Holder.LUA_CDIR;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_SHRDIR "!\..\share\lua\5.4\"
     * }
     */
    public static MemorySegment LUA_SHRDIR() {
        class Holder {
            static final MemorySegment LUA_SHRDIR
                = lualib_h.LIBRARY_ARENA.allocateFrom("!\\..\\share\\lua\\5.4\\");
        }
        return Holder.LUA_SHRDIR;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_PATH_DEFAULT "!\lua\?.lua;!\lua\?\init.lua;!\?.lua;!\?\init.lua;!\..\share\lua\5.4\?.lua;!\..\share\lua\5.4\?\init.lua;.\?.lua;.\?\init.lua"
     * }
     */
    public static MemorySegment LUA_PATH_DEFAULT() {
        class Holder {
            static final MemorySegment LUA_PATH_DEFAULT
                = lualib_h.LIBRARY_ARENA.allocateFrom("!\\lua\\?.lua;!\\lua\\?\\init.lua;!\\?.lua;!\\?\\init.lua;!\\..\\share\\lua\\5.4\\?.lua;!\\..\\share\\lua\\5.4\\?\\init.lua;.\\?.lua;.\\?\\init.lua");
        }
        return Holder.LUA_PATH_DEFAULT;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_CPATH_DEFAULT "!\?.dll;!\..\lib\lua\5.4\?.dll;!\loadall.dll;.\?.dll"
     * }
     */
    public static MemorySegment LUA_CPATH_DEFAULT() {
        class Holder {
            static final MemorySegment LUA_CPATH_DEFAULT
                = lualib_h.LIBRARY_ARENA.allocateFrom("!\\?.dll;!\\..\\lib\\lua\\5.4\\?.dll;!\\loadall.dll;.\\?.dll");
        }
        return Holder.LUA_CPATH_DEFAULT;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_DIRSEP "\"
     * }
     */
    public static MemorySegment LUA_DIRSEP() {
        class Holder {
            static final MemorySegment LUA_DIRSEP
                = lualib_h.LIBRARY_ARENA.allocateFrom("\\");
        }
        return Holder.LUA_DIRSEP;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_NUMBER_FRMLEN ""
     * }
     */
    public static MemorySegment LUA_NUMBER_FRMLEN() {
        class Holder {
            static final MemorySegment LUA_NUMBER_FRMLEN
                = lualib_h.LIBRARY_ARENA.allocateFrom("");
        }
        return Holder.LUA_NUMBER_FRMLEN;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_NUMBER_FMT "%.14g"
     * }
     */
    public static MemorySegment LUA_NUMBER_FMT() {
        class Holder {
            static final MemorySegment LUA_NUMBER_FMT
                = lualib_h.LIBRARY_ARENA.allocateFrom("%.14g");
        }
        return Holder.LUA_NUMBER_FMT;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_INTEGER_FMT "%lld"
     * }
     */
    public static MemorySegment LUA_INTEGER_FMT() {
        class Holder {
            static final MemorySegment LUA_INTEGER_FMT
                = lualib_h.LIBRARY_ARENA.allocateFrom("%lld");
        }
        return Holder.LUA_INTEGER_FMT;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_INTEGER_FRMLEN "ll"
     * }
     */
    public static MemorySegment LUA_INTEGER_FRMLEN() {
        class Holder {
            static final MemorySegment LUA_INTEGER_FRMLEN
                = lualib_h.LIBRARY_ARENA.allocateFrom("ll");
        }
        return Holder.LUA_INTEGER_FRMLEN;
    }
    private static final long LUA_MAXINTEGER = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LUA_MAXINTEGER 9223372036854775807
     * }
     */
    public static long LUA_MAXINTEGER() {
        return LUA_MAXINTEGER;
    }
    private static final long LUA_MININTEGER = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LUA_MININTEGER -9223372036854775808
     * }
     */
    public static long LUA_MININTEGER() {
        return LUA_MININTEGER;
    }
    private static final long LUA_MAXUNSIGNED = -1L;
    /**
     * {@snippet lang=c :
     * #define LUA_MAXUNSIGNED -1
     * }
     */
    public static long LUA_MAXUNSIGNED() {
        return LUA_MAXUNSIGNED;
    }
    private static final long LUA_EXTRASPACE = 8L;
    /**
     * {@snippet lang=c :
     * #define LUA_EXTRASPACE 8
     * }
     */
    public static long LUA_EXTRASPACE() {
        return LUA_EXTRASPACE;
    }
    private static final int LUAL_BUFFERSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define LUAL_BUFFERSIZE 1024
     * }
     */
    public static int LUAL_BUFFERSIZE() {
        return LUAL_BUFFERSIZE;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_VERSION_MAJOR "5"
     * }
     */
    public static MemorySegment LUA_VERSION_MAJOR() {
        class Holder {
            static final MemorySegment LUA_VERSION_MAJOR
                = lualib_h.LIBRARY_ARENA.allocateFrom("5");
        }
        return Holder.LUA_VERSION_MAJOR;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_VERSION_MINOR "4"
     * }
     */
    public static MemorySegment LUA_VERSION_MINOR() {
        class Holder {
            static final MemorySegment LUA_VERSION_MINOR
                = lualib_h.LIBRARY_ARENA.allocateFrom("4");
        }
        return Holder.LUA_VERSION_MINOR;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_VERSION_RELEASE "4"
     * }
     */
    public static MemorySegment LUA_VERSION_RELEASE() {
        class Holder {
            static final MemorySegment LUA_VERSION_RELEASE
                = lualib_h.LIBRARY_ARENA.allocateFrom("4");
        }
        return Holder.LUA_VERSION_RELEASE;
    }
    private static final int LUA_VERSION_RELEASE_NUM = (int)50404L;
    /**
     * {@snippet lang=c :
     * #define LUA_VERSION_RELEASE_NUM 50404
     * }
     */
    public static int LUA_VERSION_RELEASE_NUM() {
        return LUA_VERSION_RELEASE_NUM;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_VERSION "Lua 5.4"
     * }
     */
    public static MemorySegment LUA_VERSION() {
        class Holder {
            static final MemorySegment LUA_VERSION
                = lualib_h.LIBRARY_ARENA.allocateFrom("Lua 5.4");
        }
        return Holder.LUA_VERSION;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_RELEASE "Lua 5.4.4"
     * }
     */
    public static MemorySegment LUA_RELEASE() {
        class Holder {
            static final MemorySegment LUA_RELEASE
                = lualib_h.LIBRARY_ARENA.allocateFrom("Lua 5.4.4");
        }
        return Holder.LUA_RELEASE;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_COPYRIGHT "Lua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio"
     * }
     */
    public static MemorySegment LUA_COPYRIGHT() {
        class Holder {
            static final MemorySegment LUA_COPYRIGHT
                = lualib_h.LIBRARY_ARENA.allocateFrom("Lua 5.4.4  Copyright (C) 1994-2022 Lua.org, PUC-Rio");
        }
        return Holder.LUA_COPYRIGHT;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_AUTHORS "R. Ierusalimschy, L. H. de Figueiredo, W. Celes"
     * }
     */
    public static MemorySegment LUA_AUTHORS() {
        class Holder {
            static final MemorySegment LUA_AUTHORS
                = lualib_h.LIBRARY_ARENA.allocateFrom("R. Ierusalimschy, L. H. de Figueiredo, W. Celes");
        }
        return Holder.LUA_AUTHORS;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_SIGNATURE "Lua"
     * }
     */
    public static MemorySegment LUA_SIGNATURE() {
        class Holder {
            static final MemorySegment LUA_SIGNATURE
                = lualib_h.LIBRARY_ARENA.allocateFrom("\u001bLua");
        }
        return Holder.LUA_SIGNATURE;
    }
    private static final int LUA_MULTRET = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define LUA_MULTRET -1
     * }
     */
    public static int LUA_MULTRET() {
        return LUA_MULTRET;
    }
    private static final int LUA_REGISTRYINDEX = (int)-1001000L;
    /**
     * {@snippet lang=c :
     * #define LUA_REGISTRYINDEX -1001000
     * }
     */
    public static int LUA_REGISTRYINDEX() {
        return LUA_REGISTRYINDEX;
    }
    private static final int LUA_TNONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define LUA_TNONE -1
     * }
     */
    public static int LUA_TNONE() {
        return LUA_TNONE;
    }
    private static final int LUA_RIDX_LAST = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_RIDX_LAST 2
     * }
     */
    public static int LUA_RIDX_LAST() {
        return LUA_RIDX_LAST;
    }
    private static final int LUA_NUMTAGS = (int)9L;
    /**
     * {@snippet lang=c :
     * #define LUA_NUMTAGS 9
     * }
     */
    public static int LUA_NUMTAGS() {
        return LUA_NUMTAGS;
    }
    private static final int LUA_MASKCALL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LUA_MASKCALL 1
     * }
     */
    public static int LUA_MASKCALL() {
        return LUA_MASKCALL;
    }
    private static final int LUA_MASKRET = (int)2L;
    /**
     * {@snippet lang=c :
     * #define LUA_MASKRET 2
     * }
     */
    public static int LUA_MASKRET() {
        return LUA_MASKRET;
    }
    private static final int LUA_MASKLINE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define LUA_MASKLINE 4
     * }
     */
    public static int LUA_MASKLINE() {
        return LUA_MASKLINE;
    }
    private static final int LUA_MASKCOUNT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define LUA_MASKCOUNT 8
     * }
     */
    public static int LUA_MASKCOUNT() {
        return LUA_MASKCOUNT;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_VERSUFFIX "_5_4"
     * }
     */
    public static MemorySegment LUA_VERSUFFIX() {
        class Holder {
            static final MemorySegment LUA_VERSUFFIX
                = lualib_h.LIBRARY_ARENA.allocateFrom("_5_4");
        }
        return Holder.LUA_VERSUFFIX;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_COLIBNAME "coroutine"
     * }
     */
    public static MemorySegment LUA_COLIBNAME() {
        class Holder {
            static final MemorySegment LUA_COLIBNAME
                = lualib_h.LIBRARY_ARENA.allocateFrom("coroutine");
        }
        return Holder.LUA_COLIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_TABLIBNAME "table"
     * }
     */
    public static MemorySegment LUA_TABLIBNAME() {
        class Holder {
            static final MemorySegment LUA_TABLIBNAME
                = lualib_h.LIBRARY_ARENA.allocateFrom("table");
        }
        return Holder.LUA_TABLIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_IOLIBNAME "io"
     * }
     */
    public static MemorySegment LUA_IOLIBNAME() {
        class Holder {
            static final MemorySegment LUA_IOLIBNAME
                = lualib_h.LIBRARY_ARENA.allocateFrom("io");
        }
        return Holder.LUA_IOLIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_OSLIBNAME "os"
     * }
     */
    public static MemorySegment LUA_OSLIBNAME() {
        class Holder {
            static final MemorySegment LUA_OSLIBNAME
                = lualib_h.LIBRARY_ARENA.allocateFrom("os");
        }
        return Holder.LUA_OSLIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_STRLIBNAME "string"
     * }
     */
    public static MemorySegment LUA_STRLIBNAME() {
        class Holder {
            static final MemorySegment LUA_STRLIBNAME
                = lualib_h.LIBRARY_ARENA.allocateFrom("string");
        }
        return Holder.LUA_STRLIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_UTF8LIBNAME "utf8"
     * }
     */
    public static MemorySegment LUA_UTF8LIBNAME() {
        class Holder {
            static final MemorySegment LUA_UTF8LIBNAME
                = lualib_h.LIBRARY_ARENA.allocateFrom("utf8");
        }
        return Holder.LUA_UTF8LIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_MATHLIBNAME "math"
     * }
     */
    public static MemorySegment LUA_MATHLIBNAME() {
        class Holder {
            static final MemorySegment LUA_MATHLIBNAME
                = lualib_h.LIBRARY_ARENA.allocateFrom("math");
        }
        return Holder.LUA_MATHLIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_DBLIBNAME "debug"
     * }
     */
    public static MemorySegment LUA_DBLIBNAME() {
        class Holder {
            static final MemorySegment LUA_DBLIBNAME
                = lualib_h.LIBRARY_ARENA.allocateFrom("debug");
        }
        return Holder.LUA_DBLIBNAME;
    }
    /**
     * {@snippet lang=c :
     * #define LUA_LOADLIBNAME "package"
     * }
     */
    public static MemorySegment LUA_LOADLIBNAME() {
        class Holder {
            static final MemorySegment LUA_LOADLIBNAME
                = lualib_h.LIBRARY_ARENA.allocateFrom("package");
        }
        return Holder.LUA_LOADLIBNAME;
    }
}

